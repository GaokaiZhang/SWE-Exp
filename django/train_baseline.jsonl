{"instance_id": "django__django-10097", "model_patch": "--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -94,7 +94,7 @@\n \n     regex = _lazy_re_compile(\n         r'^(?:[a-z0-9\\.\\-\\+]*)://'  # scheme is validated separately\n-        r'(?:\\S+(?::\\S*)?@)?'  # user:pass authentication\n+        r'(?:[^:@/\\s%]+(?:%[0-9A-Fa-f]{2})*(?::[^:@/\\s%]*(?:%[0-9A-Fa-f]{2})*)?@)?'  # user:pass authentication\n         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n         r'(?::\\d{2,5})?'  # port\n         r'(?:[/?#][^\\s]*)?'  # resource path\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-10554", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -2032,6 +2032,11 @@\n         self.clear_deferred_loading()\n         self.clear_select_fields()\n \n+        # Clear ordering for combinator queries to prevent 'ORDER BY position X\n+        # is not in select list' errors when the SELECT clause is modified.\n+        if self.combinator:\n+            self.clear_ordering(force_empty=True)\n+\n         if self.group_by is True:\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-10880", "model_patch": "--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -68,7 +68,7 @@\n         return []\n \n     def as_sql(self, compiler, connection, **extra_context):\n-        extra_context['distinct'] = 'DISTINCT' if self.distinct else ''\n+        extra_context['distinct'] = 'DISTINCT ' if self.distinct else ''\n         if self.filter:\n             if connection.features.supports_aggregate_filter_clause:\n                 filter_sql, filter_params = self.filter.as_sql(compiler, connection)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-10914", "model_patch": "--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -304,7 +304,7 @@\n \n # The numeric mode to set newly-uploaded files to. The value should be a mode\n # you'd pass directly to os.chmod; see https://docs.python.org/library/os.html#files-and-directories.\n-FILE_UPLOAD_PERMISSIONS = None\n+FILE_UPLOAD_PERMISSIONS = 0o644\n \n # The numeric mode to assign to newly-created directories, when uploading files.\n # The value should be a mode as you'd pass to os.chmod;\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-10973", "model_patch": "--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -34,38 +34,19 @@\n             args += ['-p', str(port)]\n         args += [dbname]\n \n-        temp_pgpass = None\n+        # Create a custom environment with PGPASSWORD if password is provided\n+        env = os.environ.copy()\n+        if passwd:\n+            env['PGPASSWORD'] = passwd\n+\n         sigint_handler = signal.getsignal(signal.SIGINT)\n         try:\n-            if passwd:\n-                # Create temporary .pgpass file.\n-                temp_pgpass = NamedTemporaryFile(mode='w+')\n-                try:\n-                    print(\n-                        _escape_pgpass(host) or '*',\n-                        str(port) or '*',\n-                        _escape_pgpass(dbname) or '*',\n-                        _escape_pgpass(user) or '*',\n-                        _escape_pgpass(passwd),\n-                        file=temp_pgpass,\n-                        sep=':',\n-                        flush=True,\n-                    )\n-                    os.environ['PGPASSFILE'] = temp_pgpass.name\n-                except UnicodeEncodeError:\n-                    # If the current locale can't encode the data, let the\n-                    # user input the password manually.\n-                    pass\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\n-            subprocess.check_call(args)\n+            subprocess.run(args, env=env, check=True)\n         finally:\n             # Restore the original SIGINT handler.\n             signal.signal(signal.SIGINT, sigint_handler)\n-            if temp_pgpass:\n-                temp_pgpass.close()\n-                if 'PGPASSFILE' in os.environ:  # unit tests need cleanup\n-                    del os.environ['PGPASSFILE']\n \n     def runshell(self):\n         DatabaseClient.runshell_db(self.connection.get_connection_params())\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-10999", "model_patch": "--- a/django/utils/dateparse.py\n+++ b/django/utils/dateparse.py\n@@ -29,7 +29,7 @@\n standard_duration_re = re.compile(\n     r'^'\n     r'(?:(?P<days>-?\\d+) (days?, )?)?'\n-    r'((?:(?P<hours>-?\\d+):)(?=\\d+:\\d+))?'\n+    r'((?:(?P<hours>-?\\d+):)(?=-?\\d+:-?\\d+))?'\n     r'(?:(?P<minutes>-?\\d+):)?'\n     r'(?P<seconds>-?\\d+)'\n     r'(?:\\.(?P<microseconds>\\d{1,6})\\d{0,6})?'\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11066", "model_patch": "--- a/django/contrib/contenttypes/management/__init__.py\n+++ b/django/contrib/contenttypes/management/__init__.py\n@@ -24,7 +24,7 @@\n             content_type.model = new_model\n             try:\n                 with transaction.atomic(using=db):\n-                    content_type.save(update_fields={'model'})\n+                    content_type.save(using=db, update_fields={'model'})\n             except IntegrityError:\n                 # Gracefully fallback if a stale content type causes a\n                 # conflict as remove_stale_contenttypes will take care of\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11087", "model_patch": "--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -234,7 +234,7 @@\n         \"\"\"\n         return related.related_model._base_manager.using(self.using).filter(\n             **{\"%s__in\" % related.field.name: objs}\n-        )\n+        ).only('pk')\n \n     def instances_with_model(self):\n         for model, instances in self.data.items():\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11095", "model_patch": "--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -580,9 +580,17 @@\n     def __str__(self):\n         return \"%s.%s\" % (self.model._meta.app_label, self.__class__.__name__)\n \n+    def get_inlines(self, request, obj=None):\n+        \"\"\"\n+        Hook for specifying the inlines to use for the given request or model instance.\n+        \n+        By default, returns self.inlines.\n+        \"\"\"\n+        return self.inlines\n+\n     def get_inline_instances(self, request, obj=None):\n         inline_instances = []\n-        for inline_class in self.inlines:\n+        for inline_class in self.get_inlines(request, obj):\n             inline = inline_class(self.model, self.admin_site)\n             if request:\n                 if not (inline.has_view_or_change_permission(request, obj) or\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11099", "model_patch": "--- a/django/contrib/auth/validators.py\n+++ b/django/contrib/auth/validators.py\n@@ -7,7 +7,7 @@\n \n @deconstructible\n class ASCIIUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only English letters, '\n         'numbers, and @/./+/-/_ characters.'\n@@ -17,7 +17,7 @@\n \n @deconstructible\n class UnicodeUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only letters, '\n         'numbers, and @/./+/-/_ characters.'\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11119", "model_patch": "--- a/django/template/engine.py\n+++ b/django/template/engine.py\n@@ -160,7 +160,7 @@\n         if isinstance(context, Context):\n             return t.render(context)\n         else:\n-            return t.render(Context(context))\n+            return t.render(Context(context, autoescape=self.autoescape))\n \n     def select_template(self, template_name_list):\n         \"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11133", "model_patch": "--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,8 @@\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11138", "model_patch": "--- a/django/db/backends/mysql/operations.py\n+++ b/django/db/backends/mysql/operations.py\n@@ -70,7 +70,7 @@\n \n     def _convert_field_to_tz(self, field_name, tzname):\n         if settings.USE_TZ:\n-            field_name = \"CONVERT_TZ(%s, 'UTC', '%s')\" % (field_name, tzname)\n+            field_name = \"CONVERT_TZ(%s, '%s', '%s')\" % (field_name, self.connection.timezone_name, tzname)\n         return field_name\n \n     def datetime_cast_date_sql(self, field_name, tzname):\n\n--- a/django/db/backends/oracle/operations.py\n+++ b/django/db/backends/oracle/operations.py\n@@ -101,7 +101,7 @@\n             raise ValueError(\"Invalid time zone name: %s\" % tzname)\n         # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE\n         # and cast it back to TIMESTAMP to strip the TIME ZONE details.\n-        return \"CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)\" % (field_name, tzname)\n+        return \"CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)\" % (field_name, self.connection.timezone_name, tzname)\n \n     def datetime_cast_date_sql(self, field_name, tzname):\n         field_name = self._convert_field_to_tz(field_name, tzname)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11141", "model_patch": "--- a/django/db/migrations/loader.py\n+++ b/django/db/migrations/loader.py\n@@ -84,11 +84,6 @@\n                     continue\n                 raise\n             else:\n-                # Empty directories are namespaces.\n-                # getattr() needed on PY36 and older (replace w/attribute access).\n-                if getattr(module, '__file__', None) is None:\n-                    self.unmigrated_apps.add(app_config.label)\n-                    continue\n                 # Module is not a package (e.g. migrations.py).\n                 if not hasattr(module, '__path__'):\n                     self.unmigrated_apps.add(app_config.label)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11149", "model_patch": "--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -2115,18 +2115,32 @@\n         if self.opts.auto_created:\n             # We're checking the rights to an auto-created intermediate model,\n             # which doesn't have its own individual permissions. The user needs\n-            # to have the view permission for the related model in order to\n-            # be able to do anything with the intermediate model.\n-            return self.has_view_permission(request, obj)\n+            # to have the change permission for the related model in order to\n+            # be able to add to the intermediate model.\n+            opts = self.opts\n+            # The model was auto-created as intermediary for a many-to-many\n+            # Many-relationship; find the target model.\n+            for field in opts.fields:\n+                if field.remote_field and field.remote_field.model != self.parent_model:\n+                    opts = field.remote_field.model._meta\n+                    break\n+            return request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename('change', opts)))\n         return super().has_add_permission(request)\n \n     def has_change_permission(self, request, obj=None):\n         if self.opts.auto_created:\n             # We're checking the rights to an auto-created intermediate model,\n             # which doesn't have its own individual permissions. The user needs\n-            # to have the view permission for the related model in order to\n-            # be able to do anything with the intermediate model.\n-            return self.has_view_permission(request, obj)\n+            # to have the change permission for the related model in order to\n+            # be able to change the intermediate model.\n+            opts = self.opts\n+            # The model was auto-created as intermediary for a many-to-many\n+            # Many-relationship; find the target model.\n+            for field in opts.fields:\n+                if field.remote_field and field.remote_field.model != self.parent_model:\n+                    opts = field.remote_field.model._meta\n+                    break\n+            return request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename('change', opts)))\n         return super().has_change_permission(request)\n \n     def has_delete_permission(self, request, obj=None):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11163", "model_patch": "--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -83,7 +83,7 @@\n     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):\n         if not getattr(f, 'editable', False):\n             continue\n-        if fields and f.name not in fields:\n+        if fields is not None and f.name not in fields:\n             continue\n         if exclude and f.name in exclude:\n             continue\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11179", "model_patch": "--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -277,6 +277,7 @@\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11206", "model_patch": "--- a/django/utils/numberformat.py\n+++ b/django/utils/numberformat.py\n@@ -31,14 +31,19 @@\n         # scientific notation to avoid high memory usage in {:f}'.format().\n         _, digits, exponent = number.as_tuple()\n         if abs(exponent) + len(digits) > 200:\n-            number = '{:e}'.format(number)\n-            coefficient, exponent = number.split('e')\n-            # Format the coefficient.\n-            coefficient = format(\n-                coefficient, decimal_sep, decimal_pos, grouping,\n-                thousand_sep, force_grouping, use_l10n,\n-            )\n-            return '{}e{}'.format(coefficient, exponent)\n+            # If decimal_pos is specified and the number is effectively zero\n+            # at that precision, return zero-padded string instead of scientific notation\n+            if decimal_pos is not None and abs(number) < Decimal(10) ** (-decimal_pos):\n+                str_number = '0.0'\n+            else:\n+                number = '{:e}'.format(number)\n+                coefficient, exponent = number.split('e')\n+                # Format the coefficient.\n+                coefficient = format(\n+                    coefficient, decimal_sep, decimal_pos, grouping,\n+                    thousand_sep, force_grouping, use_l10n,\n+                )\n+                return '{}e{}'.format(coefficient, exponent)\n         else:\n             str_number = '{:f}'.format(number)\n     else:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11211", "model_patch": "--- a/django/contrib/contenttypes/fields.py\n+++ b/django/contrib/contenttypes/fields.py\n@@ -207,7 +207,7 @@\n \n         return (\n             ret_val,\n-            lambda obj: (obj.pk, obj.__class__),\n+            lambda obj: (obj._meta.pk.get_prep_value(obj.pk), obj.__class__),\n             gfk_key,\n             True,\n             self.name,\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11239", "model_patch": "--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -30,6 +30,17 @@\n         subprocess_env = os.environ.copy()\n         if passwd:\n             subprocess_env['PGPASSWORD'] = str(passwd)\n+        \n+        # Set SSL environment variables if present\n+        ssl_params = {\n+            'sslmode': 'PGSSLMODE',\n+            'sslrootcert': 'PGSSLROOTCERT', \n+            'sslcert': 'PGSSLCERT',\n+            'sslkey': 'PGSSLKEY'\n+        }\n+        for param, env_var in ssl_params.items():\n+            if param in conn_params:\n+                subprocess_env[env_var] = str(conn_params[param])\n         try:\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11265", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1666,6 +1666,7 @@\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\n+        query._filtered_relations = self._filtered_relations.copy()\n         query.add_filter(filter_expr)\n         query.clear_ordering(True)\n         # Try to have as simple as possible subquery -> trim leading joins from\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11276", "model_patch": "--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -2,6 +2,7 @@\n \n import json\n import re\n+from html import escape as html_escape\n from html.parser import HTMLParser\n from urllib.parse import (\n     parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit,\n@@ -43,7 +44,7 @@\n     This may result in double-escaping. If this is a concern, use\n     conditional_escape() instead.\n     \"\"\"\n-    return mark_safe(str(text).translate(_html_escapes))\n+    return mark_safe(html_escape(str(text)))\n \n \n _js_escapes = {\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11292", "model_patch": "--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -285,6 +285,10 @@\n         parser.add_argument(\n             '--force-color', action='store_true',\n             help='Force colorization of the command output.',\n+        )\n+        parser.add_argument(\n+            '--skip-checks', action='store_true',\n+            help='Skip system checks.',\n         )\n         self.add_arguments(parser)\n         return parser\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11299", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1338,7 +1338,7 @@\n             if isinstance(child, Node):\n                 child_clause, needed_inner = self._add_q(\n                     child, used_aliases, branch_negated,\n-                    current_negated, allow_joins, split_subq)\n+                    current_negated, allow_joins, split_subq, simple_col)\n                 joinpromoter.add_votes(needed_inner)\n             else:\n                 child_clause, needed_inner = self.build_filter(\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11333", "model_patch": "--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -63,10 +63,14 @@\n         )\n \n \n-@functools.lru_cache(maxsize=None)\n def get_resolver(urlconf=None):\n     if urlconf is None:\n         urlconf = settings.ROOT_URLCONF\n+    return _get_resolver(urlconf)\n+\n+\n+@functools.lru_cache(maxsize=None)\n+def _get_resolver(urlconf):\n     return URLResolver(RegexPattern(r'^/'), urlconf)\n \n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11400", "model_patch": "--- a/django/contrib/admin/filters.py\n+++ b/django/contrib/admin/filters.py\n@@ -198,6 +198,8 @@\n         related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n         if related_admin is not None:\n             ordering = related_admin.get_ordering(request)\n+        if not ordering:\n+            ordering = field.remote_field.model._meta.ordering\n         return field.get_choices(include_blank=False, ordering=ordering)\n \n     def choices(self, changelist):\n@@ -419,4 +421,10 @@\n class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n     def field_choices(self, field, request, model_admin):\n         pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n-        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs})\n+        ordering = ()\n+        related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n+        if related_admin is not None:\n+            ordering = related_admin.get_ordering(request)\n+        if not ordering:\n+            ordering = field.remote_field.model._meta.ordering\n+        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs}, ordering=ordering)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11433", "model_patch": "--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -49,7 +49,8 @@\n         # Leave defaults for fields that aren't in POST data, except for\n         # checkbox inputs because they don't appear in POST data if not checked.\n         if (f.has_default() and\n-                form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name))):\n+                form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name)) and\n+                f.name not in cleaned_data):\n             continue\n         # Defer saving file-type fields until after the other fields, so a\n         # callable upload_to can use the values from other fields.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11451", "model_patch": "--- a/django/contrib/auth/backends.py\n+++ b/django/contrib/auth/backends.py\n@@ -39,6 +39,8 @@\n     def authenticate(self, request, username=None, password=None, **kwargs):\n         if username is None:\n             username = kwargs.get(UserModel.USERNAME_FIELD)\n+        if username is None or password is None:\n+            return\n         try:\n             user = UserModel._default_manager.get_by_natural_key(username)\n         except UserModel.DoesNotExist:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11477", "model_patch": "--- a/django/urls/base.py\n+++ b/django/urls/base.py\n@@ -172,7 +172,14 @@\n         to_be_reversed = \"%s:%s\" % (match.namespace, match.url_name) if match.namespace else match.url_name\n         with override(lang_code):\n             try:\n-                url = reverse(to_be_reversed, args=match.args, kwargs=match.kwargs)\n+                # Include any default arguments from the URL pattern to handle optional named groups\n+                kwargs = match.kwargs.copy()\n+                if hasattr(match, 'default_args') and match.default_args:\n+                    # Add default values for optional parameters that weren't captured\n+                    for key, value in match.default_args.items():\n+                        if key not in kwargs:\n+                            kwargs[key] = value\n+                url = reverse(to_be_reversed, args=match.args, kwargs=kwargs)\n             except NoReverseMatch:\n                 pass\n             else:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11490", "model_patch": "--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -424,8 +424,8 @@\n             try:\n                 # If the columns list is limited, then all combined queries\n                 # must have the same columns list. Set the selects defined on\n-                # the query on all combined queries, if not already set.\n-                if not compiler.query.values_select and self.query.values_select:\n+                # the query on all combined queries.\n+                if self.query.values_select:\n                     compiler.query.set_values((\n                         *self.query.extra_select,\n                         *self.query.values_select,\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11532", "model_patch": "--- a/django/core/mail/utils.py\n+++ b/django/core/mail/utils.py\n@@ -13,7 +13,13 @@\n \n     def get_fqdn(self):\n         if not hasattr(self, '_fqdn'):\n-            self._fqdn = socket.getfqdn()\n+            hostname = socket.getfqdn()\n+            try:\n+                # Convert unicode hostname to ASCII-compatible punycode\n+                self._fqdn = hostname.encode('idna').decode('ascii')\n+            except (UnicodeError, UnicodeDecodeError):\n+                # Fallback to original hostname if encoding fails\n+                self._fqdn = hostname\n         return self._fqdn\n \n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11551", "model_patch": "--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -720,33 +720,33 @@\n             return []\n         elif hasattr(obj, item):\n             return []\n-        elif hasattr(obj.model, item):\n+        else:\n             try:\n                 field = obj.model._meta.get_field(item)\n             except FieldDoesNotExist:\n-                return []\n-            else:\n-                if isinstance(field, models.ManyToManyField):\n+                try:\n+                    field = getattr(obj.model, item)\n+                except AttributeError:\n                     return [\n                         checks.Error(\n-                            \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                            \"The value of '%s' refers to '%s', which is not a callable, \"\n+                            \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n+                                label, item, obj.__class__.__name__,\n+                                obj.model._meta.app_label, obj.model._meta.object_name,\n+                            ),\n                             obj=obj.__class__,\n-                            id='admin.E109',\n+                            id='admin.E108',\n                         )\n                     ]\n-                return []\n-        else:\n-            return [\n-                checks.Error(\n-                    \"The value of '%s' refers to '%s', which is not a callable, \"\n-                    \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n-                        label, item, obj.__class__.__name__,\n-                        obj.model._meta.app_label, obj.model._meta.object_name,\n-                    ),\n-                    obj=obj.__class__,\n-                    id='admin.E108',\n-                )\n-            ]\n+            if isinstance(field, models.ManyToManyField):\n+                return [\n+                    checks.Error(\n+                        \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                        obj=obj.__class__,\n+                        id='admin.E109',\n+                    )\n+                ]\n+            return []\n \n     def _check_list_display_links(self, obj):\n         \"\"\" Check that list_display_links is a unique subset of list_display.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11555", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -2217,7 +2217,19 @@\n     The 'default' param is used to indicate which way no prefix (or a '+'\n     prefix) should sort. The '-' prefix always sorts the opposite way.\n     \"\"\"\n+    from django.db.models.expressions import OrderBy\n+    \n     dirn = ORDER_DIR[default]\n+    \n+    # Handle OrderBy objects from Meta.ordering expressions\n+    if isinstance(field, OrderBy):\n+        # Extract field name from the expression\n+        field_name = str(field.expression)\n+        # Use descending attribute to determine direction\n+        direction = 'DESC' if field.descending else 'ASC'\n+        return field_name, direction\n+    \n+    # Handle string fields (existing logic)\n     if field[0] == '-':\n         return field[1:], dirn[1]\n     return field, dirn[0]\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11603", "model_patch": "--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -99,6 +99,7 @@\n class Avg(FixDurationInputMixin, NumericOutputFieldMixin, Aggregate):\n     function = 'AVG'\n     name = 'Avg'\n+    allow_distinct = True\n \n \n class Count(Aggregate):\n@@ -142,6 +143,7 @@\n class Sum(FixDurationInputMixin, Aggregate):\n     function = 'SUM'\n     name = 'Sum'\n+    allow_distinct = True\n \n \n class Variance(NumericOutputFieldMixin, Aggregate):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11728", "model_patch": "--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -151,6 +151,8 @@\n \n \n def replace_named_groups(pattern):\n+    # Debug: Let's add some debugging to understand the issue\n+    print(f\"DEBUG: Input pattern: {pattern}\")\n     r\"\"\"\n     Find named groups in `pattern` and replace them with the group name. E.g.,\n     1. ^(?P<a>\\w+)/b/(\\w+)$ ==> ^<a>/b/(\\w+)$\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11734", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1045,8 +1045,13 @@\n             sql = '(%s)' % sql\n         return sql, params\n \n-    def resolve_lookup_value(self, value, can_reuse, allow_joins, simple_col):\n+    def resolve_lookup_value(self, value, can_reuse, allow_joins, simple_col, branch_negated=False):\n         if hasattr(value, 'resolve_expression'):\n+            # Special handling for OuterRef in negated contexts\n+            if isinstance(value, OuterRef) and branch_negated:\n+                # Don't resolve OuterRef in negated contexts (exclude, ~Q)\n+                # Let it be resolved later when subquery context is established\n+                return value\n             kwargs = {'reuse': can_reuse, 'allow_joins': allow_joins}\n             if isinstance(value, F):\n                 kwargs['simple_col'] = simple_col\n@@ -1057,7 +1062,10 @@\n             resolved_values = []\n             for sub_value in value:\n                 if hasattr(sub_value, 'resolve_expression'):\n-                    if isinstance(sub_value, F):\n+                    # Special handling for OuterRef in negated contexts\n+                    if isinstance(sub_value, OuterRef) and branch_negated:\n+                        resolved_values.append(sub_value)\n+                    elif isinstance(sub_value, F):\n                         resolved_values.append(sub_value.resolve_expression(\n                             self, reuse=can_reuse, allow_joins=allow_joins,\n                             simple_col=simple_col,\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11740", "model_patch": "--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -963,6 +963,10 @@\n                             preserve_default = False\n                     else:\n                         field = new_field\n+                    # Check if the new field has foreign key dependencies\n+                    dependencies = []\n+                    if field.remote_field and field.remote_field.model:\n+                        dependencies.extend(self._get_dependencies_for_foreign_key(field))\n                     self.add_operation(\n                         app_label,\n                         operations.AlterField(\n@@ -970,7 +974,8 @@\n                             name=field_name,\n                             field=field,\n                             preserve_default=preserve_default,\n-                        )\n+                        ),\n+                        dependencies=dependencies,\n                     )\n                 else:\n                     # We cannot alter between m2m and concrete fields\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11749", "model_patch": "--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -130,6 +130,15 @@\n                 yield opt\n \n     parser_actions = list(get_actions(parser))\n+    \n+    # Handle required mutually exclusive groups\n+    for group in parser._mutually_exclusive_groups:\n+        if group.required:\n+            # Check if any argument from this group is present in options\n+            for action in group._group_actions:\n+                if action.dest in arg_options:\n+                    parse_args.append('{}={}'.format(min(action.option_strings), arg_options[action.dest]))\n+    \n     # Any required arguments which are passed in via **options must be passed\n     # to parse_args().\n     parse_args += [\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11790", "model_patch": "--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -62,11 +62,12 @@\n         return unicodedata.normalize('NFKC', super().to_python(value))\n \n     def widget_attrs(self, widget):\n-        return {\n-            **super().widget_attrs(widget),\n+        attrs = super().widget_attrs(widget)\n+        attrs.update({\n             'autocapitalize': 'none',\n             'autocomplete': 'username',\n-        }\n+        })\n+        return attrs\n \n \n class UserCreationForm(forms.ModelForm):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11815", "model_patch": "--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,9 +120,9 @@\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n-        imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n+        name_string, name_imports = serializer_factory(self.value.name).serialize()\n+        imports = {'import %s' % module, *name_imports}\n+        return \"%s.%s[%s]\" % (module, enum_class.__name__, name_string), imports\n \n \n class FloatSerializer(BaseSimpleSerializer):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11820", "model_patch": "--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1713,14 +1713,17 @@\n                         _cls = fld.get_path_info()[-1].to_opts.model\n                 except (FieldDoesNotExist, AttributeError):\n                     if fld is None or fld.get_transform(part) is None:\n-                        errors.append(\n-                            checks.Error(\n-                                \"'ordering' refers to the nonexistent field, \"\n-                                \"related field, or lookup '%s'.\" % field,\n-                                obj=cls,\n-                                id='models.E015',\n+                        # Skip ordering on pk. This is always a valid order_by field\n+                        # but is an alias and therefore won't be found by opts.get_field.\n+                        if part != 'pk':\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'ordering' refers to the nonexistent field, \"\n+                                    \"related field, or lookup '%s'.\" % field,\n+                                    obj=cls,\n+                                    id='models.E015',\n+                                )\n                             )\n-                        )\n \n         # Skip ordering on pk. This is always a valid order_by field\n         # but is an alias and therefore won't be found by opts.get_field.\n\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -814,6 +814,20 @@\n             )\n         ])\n \n+    def test_ordering_pointing_to_related_model_pk(self):\n+        \"\"\"Test that ordering by a related field's pk should be valid.\"\"\"\n+        class Option(models.Model):\n+            name = models.CharField(max_length=50)\n+\n+        class SomeModel(models.Model):\n+            option = models.ForeignKey(Option, models.CASCADE)\n+\n+            class Meta:\n+                ordering = ('option__pk',)\n+\n+        # This should not raise any errors - ordering by related field's pk is valid\n+        self.assertEqual(SomeModel.check(), [])\n+\n     def test_ordering_allows_registered_lookups(self):\n         class Model(models.Model):\n             test = models.CharField(max_length=100)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11848", "model_patch": "--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -176,10 +176,18 @@\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n-            if year < 70:\n-                year += 2000\n+            # RFC 7231: interpret a timestamp that appears to be more than 50 years\n+            # in the future as representing the most recent year in the past that\n+            # had the same last two digits.\n+            current_year = datetime.datetime.now().year\n+            century_2000 = 2000 + year\n+            century_1900 = 1900 + year\n+            \n+            # Choose the century that doesn't put the date more than 50 years in the future\n+            if century_2000 - current_year > 50:\n+                year = century_1900\n             else:\n-                year += 1900\n+                year = century_2000\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11880", "model_patch": "--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -199,6 +199,7 @@\n         result = copy.copy(self)\n         memo[id(self)] = result\n         result.widget = copy.deepcopy(self.widget, memo)\n+        result.error_messages = copy.deepcopy(self.error_messages, memo)\n         result.validators = self.validators[:]\n         return result\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11885", "model_patch": "--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -309,10 +309,34 @@\n                         sender=model, instance=obj, using=self.using\n                     )\n \n-            # fast deletes\n+            # fast deletes - group by model and combine WHERE conditions\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, no need to combine\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n+                else:\n+                    # Multiple querysets for same model - combine with OR\n+                    combined_query = sql.DeleteQuery(model)\n+                    combined_where = combined_query.where_class()\n+                    \n+                    # Combine all WHERE conditions with OR\n+                    for qs in querysets:\n+                        # Get the WHERE condition from each queryset\n+                        qs_query = qs.query\n+                        if qs_query.where:\n+                            combined_where.add(qs_query.where, combined_where.OR)\n+                    \n+                    combined_query.where = combined_where\n+                    count = combined_query.do_query(model._meta.db_table, combined_where, using=self.using)\n+                    deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11951", "model_patch": "--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1209,7 +1209,8 @@\n         if ignore_conflicts and not connections[self.db].features.supports_ignore_conflicts:\n             raise NotSupportedError('This database backend does not support ignoring conflicts.')\n         ops = connections[self.db].ops\n-        batch_size = (batch_size or max(ops.bulk_batch_size(fields, objs), 1))\n+        max_batch_size = max(ops.bulk_batch_size(fields, objs), 1)\n+        batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n         inserted_rows = []\n         bulk_return = connections[self.db].features.can_return_rows_from_bulk_insert\n         for item in [objs[i:i + batch_size] for i in range(0, len(objs), batch_size)]:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11964", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1010,6 +1010,9 @@\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum instances by extracting their value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\n@@ -1769,6 +1772,9 @@\n     def to_python(self, value):\n         if value is None:\n             return value\n+        # Handle enum instances by extracting their value\n+        if hasattr(value, 'value'):\n+            value = value.value\n         try:\n             return int(value)\n         except (TypeError, ValueError):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-11999", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,10 @@\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            # Only set the auto-generated method if no user-defined method exists\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                setattr(cls, 'get_%s_display' % self.name,\n+                        partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12039", "model_patch": "--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -114,7 +114,9 @@\n             # length as self.columns.\n             col = '{} {}'.format(self.quote_name(column), self.opclasses[idx])\n             try:\n-                col = '{} {}'.format(col, self.col_suffixes[idx])\n+                suffix = self.col_suffixes[idx]\n+                if suffix:\n+                    col = '{} {}'.format(col, suffix)\n             except IndexError:\n                 pass\n             return col\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12050", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1073,7 +1073,8 @@\n                         ))\n                 else:\n                     resolved_values.append(sub_value)\n-            value = tuple(resolved_values)\n+            # Preserve the original iterable type instead of always coercing to tuple\n+            value = type(value)(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12125", "model_patch": "--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -269,7 +269,7 @@\n             if module == builtins.__name__:\n                 return self.value.__name__, set()\n             else:\n-                return \"%s.%s\" % (module, self.value.__name__), {\"import %s\" % module}\n+                return \"%s.%s\" % (module, self.value.__qualname__), {\"import %s\" % module}\n \n \n class UUIDSerializer(BaseSerializer):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12143", "model_patch": "--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1631,7 +1631,7 @@\n \n     def _get_edited_object_pks(self, request, prefix):\n         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n-        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, self.model._meta.pk.name))\n+        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name))\n         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n \n     def _get_list_editable_queryset(self, request, prefix):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12155", "model_patch": "--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -34,7 +34,7 @@\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n+    indent = min(len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip())\n     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12193", "model_patch": "--- a/django/contrib/postgres/forms/array.py\n+++ b/django/contrib/postgres/forms/array.py\n@@ -144,10 +144,13 @@\n                 widget_value = value[i]\n             except IndexError:\n                 widget_value = None\n+            # Create a copy of final_attrs for each subwidget to prevent\n+            # CheckboxInput from modifying the shared attrs dictionary\n+            widget_attrs = final_attrs.copy()\n             if id_:\n-                final_attrs = {**final_attrs, 'id': '%s_%s' % (id_, i)}\n+                widget_attrs['id'] = '%s_%s' % (id_, i)\n             context['widget']['subwidgets'].append(\n-                self.widget.get_context(name + '_%s' % i, widget_value, final_attrs)['widget']\n+                self.widget.get_context(name + '_%s' % i, widget_value, widget_attrs)['widget']\n             )\n         return context\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12209", "model_patch": "--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -840,6 +840,7 @@\n                        if f.name in update_fields or f.attname in update_fields]\n \n         pk_val = self._get_pk_val(meta)\n+        pk_val_was_none = pk_val is None\n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n@@ -847,12 +848,14 @@\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n-        # Skip an UPDATE when adding an instance and primary key has a default.\n+        # Skip an UPDATE when adding an instance and primary key has a default,\n+        # but only if no explicit primary key value was provided.\n         if (\n             not force_insert and\n             self._state.adding and\n             self._meta.pk.default and\n-            self._meta.pk.default is not NOT_PROVIDED\n+            self._meta.pk.default is not NOT_PROVIDED and\n+            pk_val_was_none\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12262", "model_patch": "--- a/django/template/library.py\n+++ b/django/template/library.py\n@@ -261,7 +261,7 @@\n         if kwarg:\n             # The kwarg was successfully extracted\n             param, value = kwarg.popitem()\n-            if param not in params and param not in unhandled_kwargs and varkw is None:\n+            if param not in params and param not in kwonly and param not in unhandled_kwargs and varkw is None:\n                 # An unexpected keyword argument was supplied\n                 raise TemplateSyntaxError(\n                     \"'%s' received unexpected keyword argument '%s'\" %\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12276", "model_patch": "--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -387,6 +387,9 @@\n     def value_omitted_from_data(self, data, files, name):\n         return name not in files\n \n+    def use_required_attribute(self, initial):\n+        return super().use_required_attribute(initial) and not initial\n+\n \n FILE_INPUT_CONTRADICTION = object()\n \n@@ -451,8 +454,7 @@\n             return False\n         return upload\n \n-    def use_required_attribute(self, initial):\n-        return super().use_required_attribute(initial) and not initial\n+\n \n     def value_omitted_from_data(self, data, files, name):\n         return (\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12304", "model_patch": "--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -27,6 +27,9 @@\n             dict.__setitem__(classdict, key, value)\n         cls = super().__new__(metacls, classname, bases, classdict)\n         cls._value2label_map_ = dict(zip(cls._value2member_map_, labels))\n+        # Add do_not_call_in_templates to prevent Django templates from calling\n+        # the enumeration class when it's used in template expressions\n+        cls.do_not_call_in_templates = True\n         # Add a label property to instances of enum which uses the enum member\n         # that is passed in as \"self\" as the value to use when looking up the\n         # label in the choices.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12308", "model_patch": "--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -6,6 +6,7 @@\n from django.db import models, router\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.deletion import Collector\n+from django.db.models.fields.json import JSONField\n from django.forms.utils import pretty_name\n from django.urls import NoReverseMatch, reverse\n from django.utils import formats, timezone\n@@ -398,6 +399,11 @@\n         return formats.number_format(value)\n     elif isinstance(field, models.FileField) and value:\n         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    elif isinstance(field, JSONField):\n+        # Create a form field instance to use its prepare_value method\n+        # This handles InvalidJSONInput case properly\n+        form_field = field.formfield()\n+        return form_field.prepare_value(value)\n     else:\n         return display_for_value(value, empty_value_display)\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12325", "model_patch": "--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -204,7 +204,12 @@\n             for field in base._meta.local_fields:\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n-                    parent_links[make_model_tuple(related)] = field\n+                    parent_key = make_model_tuple(related)\n+                    # Prioritize fields with parent_link=True over those without\n+                    existing_field = parent_links.get(parent_key)\n+                    if (existing_field is None or \n+                        (field.remote_field.parent_link and not existing_field.remote_field.parent_link)):\n+                        parent_links[parent_key] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -1015,6 +1015,34 @@\n             class ParkingLot(Place):\n                 parent = models.OneToOneField(Place, models.CASCADE)\n \n+    def test_multiple_onetoone_parent_link_order_independence(self):\n+        \"\"\"\n+        Test that when a model has multiple OneToOneField references to its parent,\n+        the field with parent_link=True is correctly identified as the parent link\n+        regardless of declaration order.\n+        \"\"\"\n+        # Test case 1: parent_link field declared first\n+        try:\n+            class Document1(models.Model):\n+                pass\n+\n+            class Picking1(Document1):\n+                document_ptr = models.OneToOneField(Document1, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+                origin = models.OneToOneField(Document1, related_name='picking1', on_delete=models.PROTECT)\n+        except ImproperlyConfigured:\n+            self.fail(\"ImproperlyConfigured should not be raised when parent_link=True field is declared first\")\n+\n+        # Test case 2: parent_link field declared second\n+        try:\n+            class Document2(models.Model):\n+                pass\n+\n+            class Picking2(Document2):\n+                origin = models.OneToOneField(Document2, related_name='picking2', on_delete=models.PROTECT)\n+                document_ptr = models.OneToOneField(Document2, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+        except ImproperlyConfigured:\n+            self.fail(\"ImproperlyConfigured should not be raised when parent_link=True field is declared second\")\n+\n     def test_m2m_table_name_clash(self):\n         class Foo(models.Model):\n             bar = models.ManyToManyField('Bar', db_table='myapp_bar')\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12406", "model_patch": "--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -975,12 +975,16 @@\n             raise ValueError(\"Cannot create form field for %r yet, because \"\n                              \"its related model %r has not been loaded yet\" %\n                              (self.name, self.remote_field.model))\n-        return super().formfield(**{\n+        defaults = {\n             'form_class': forms.ModelChoiceField,\n             'queryset': self.remote_field.model._default_manager.using(using),\n             'to_field_name': self.remote_field.field_name,\n-            **kwargs,\n-        })\n+        }\n+        # If blank=False on the model field, don't show empty label option\n+        if not self.blank:\n+            defaults['empty_label'] = None\n+        defaults.update(kwargs)\n+        return super().formfield(**defaults)\n \n     def db_check(self, connection):\n         return []\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12419", "model_patch": "--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -637,6 +637,6 @@\n SECURE_HSTS_PRELOAD = False\n SECURE_HSTS_SECONDS = 0\n SECURE_REDIRECT_EXEMPT = []\n-SECURE_REFERRER_POLICY = None\n+SECURE_REFERRER_POLICY = 'same-origin'\n SECURE_SSL_HOST = None\n SECURE_SSL_REDIRECT = False\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12663", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -21,7 +21,7 @@\n     parse_date, parse_datetime, parse_duration, parse_time,\n )\n from django.utils.duration import duration_microseconds, duration_string\n-from django.utils.functional import Promise, cached_property\n+from django.utils.functional import Promise, SimpleLazyObject, cached_property\n from django.utils.ipv6 import clean_ipv6_address\n from django.utils.itercompat import is_iterable\n from django.utils.text import capfirst\n@@ -804,6 +804,8 @@\n         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n         if isinstance(value, Promise):\n             value = value._proxy____cast()\n+        elif isinstance(value, SimpleLazyObject):\n+            value = value._wrapped if hasattr(value, '_wrapped') else value\n         return value\n \n     def get_db_prep_value(self, value, connection, prepared=False):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12708", "model_patch": "--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -405,7 +405,7 @@\n         columns = [model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            index=True, unique=False, **constraint_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12713", "model_patch": "--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -249,16 +249,17 @@\n             return None\n         db = kwargs.get('using')\n \n-        autocomplete_fields = self.get_autocomplete_fields(request)\n-        if db_field.name in autocomplete_fields:\n-            kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in self.raw_id_fields:\n-            kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n-            kwargs['widget'] = widgets.FilteredSelectMultiple(\n-                db_field.verbose_name,\n-                db_field.name in self.filter_vertical\n-            )\n+        if 'widget' not in kwargs:\n+            autocomplete_fields = self.get_autocomplete_fields(request)\n+            if db_field.name in autocomplete_fields:\n+                kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in self.raw_id_fields:\n+                kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n+                kwargs['widget'] = widgets.FilteredSelectMultiple(\n+                    db_field.verbose_name,\n+                    db_field.name in self.filter_vertical\n+                )\n \n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12741", "model_patch": "--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -400,9 +400,9 @@\n         \"\"\"\n         raise NotImplementedError('subclasses of BaseDatabaseOperations must provide a sql_flush() method')\n \n-    def execute_sql_flush(self, using, sql_list):\n+    def execute_sql_flush(self, sql_list):\n         \"\"\"Execute a list of SQL statements to flush the database.\"\"\"\n-        with transaction.atomic(using=using, savepoint=self.connection.features.can_rollback_ddl):\n+        with transaction.atomic(using=self.connection.alias, savepoint=self.connection.features.can_rollback_ddl):\n             with self.connection.cursor() as cursor:\n                 for sql in sql_list:\n                     cursor.execute(sql)\n\n--- a/django/core/management/commands/flush.py\n+++ b/django/core/management/commands/flush.py\n@@ -60,7 +60,7 @@\n \n         if confirm == 'yes':\n             try:\n-                connection.ops.execute_sql_flush(database, sql_list)\n+                connection.ops.execute_sql_flush(sql_list)\n             except Exception as exc:\n                 raise CommandError(\n                     \"Database %s couldn't be flushed. Possible reasons:\\n\"\n\n--- a/tests/backends/base/test_operations.py\n+++ b/tests/backends/base/test_operations.py\n@@ -172,7 +172,7 @@\n             reset_sequences=True,\n             allow_cascade=True,\n         )\n-        connection.ops.execute_sql_flush(connection.alias, sql_list)\n+        connection.ops.execute_sql_flush(sql_list)\n \n         with transaction.atomic():\n             self.assertIs(Author.objects.exists(), False)\n\n--- a/tests/backends/tests.py\n+++ b/tests/backends/tests.py\n@@ -162,7 +162,7 @@\n             VLM_m2m._meta.db_table,\n         ]\n         sql_list = connection.ops.sql_flush(no_style(), tables, reset_sequences=True)\n-        connection.ops.execute_sql_flush(connection.alias, sql_list)\n+        connection.ops.execute_sql_flush(sql_list)\n \n \n class SequenceResetTest(TestCase):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12754", "model_patch": "--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -165,6 +165,8 @@\n \n         # Generate non-rename model operations\n         self.generate_deleted_models()\n+        # Generate field removal operations before creating models to avoid field clashes\n+        self.generate_removed_fields()\n         self.generate_created_models()\n         self.generate_deleted_proxies()\n         self.generate_created_proxies()\n@@ -181,7 +183,6 @@\n         self.generate_removed_indexes()\n         # Generate field operations\n         self.generate_renamed_fields()\n-        self.generate_removed_fields()\n         self.generate_added_fields()\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12774", "model_patch": "--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -690,7 +690,13 @@\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\n         if field_name != 'pk' and not self.model._meta.get_field(field_name).unique:\n-            raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n+            # Check if field is unique through a single-field UniqueConstraint\n+            unique_constraint_fields = [\n+                constraint.fields[0] for constraint in self.model._meta.total_unique_constraints\n+                if len(constraint.fields) == 1\n+            ]\n+            if field_name not in unique_constraint_fields:\n+                raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n                 return {}\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12858", "model_patch": "--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1747,7 +1747,7 @@\n                     else:\n                         _cls = None\n                 except (FieldDoesNotExist, AttributeError):\n-                    if fld is None or fld.get_transform(part) is None:\n+                    if fld is None or (fld.get_transform(part) is None and fld.get_lookup(part) is None):\n                         errors.append(\n                             checks.Error(\n                                 \"'ordering' refers to the nonexistent field, \"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12965", "model_patch": "--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1423,8 +1423,22 @@\n         Create the SQL for this query. Return the SQL string and list of\n         parameters.\n         \"\"\"\n-        if self.single_alias:\n+        # Only use subquery when we actually have joins or complex conditions\n+        # that require it. For simple delete operations, use the direct approach.\n+        if self.single_alias or not self.query.alias_map or len(self.query.alias_map) <= 1:\n             return self._as_sql(self.query)\n+        \n+        # Check if we have actual joins (not just the base table)\n+        has_joins = any(\n+            alias_data.join_type is not None \n+            for alias, alias_data in self.query.alias_map.items()\n+            if alias != self.query.base_table\n+        )\n+        \n+        # If no actual joins, use the simple approach\n+        if not has_joins:\n+            return self._as_sql(self.query)\n+            \n         innerq = self.query.clone()\n         innerq.__class__ = Query\n         innerq.clear_select_clause()\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13012", "model_patch": "--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -866,6 +866,9 @@\n     def as_sql(self, compiler, connection):\n         return self.expression.as_sql(compiler, connection)\n \n+    def get_group_by_cols(self, alias=None):\n+        return self.expression.get_group_by_cols(alias)\n+\n     def __repr__(self):\n         return \"{}({})\".format(self.__class__.__name__, self.expression)\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13023", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1501,7 +1501,7 @@\n             return self.context.create_decimal_from_float(value)\n         try:\n             return decimal.Decimal(value)\n-        except decimal.InvalidOperation:\n+        except (decimal.InvalidOperation, TypeError):\n             raise exceptions.ValidationError(\n                 self.error_messages['invalid'],\n                 code='invalid',\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13028", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1124,7 +1124,8 @@\n \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n-        if not getattr(expression, 'filterable', True):\n+        if (isinstance(expression, BaseExpression) and \n+            not getattr(expression, 'filterable', True)):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13033", "model_patch": "--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,10 @@\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        # Also skip if we're ordering by a foreign key's _id field directly.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (name.endswith('_id') and getattr(field, 'attname', None) == name)):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13089", "model_patch": "--- a/django/core/cache/backends/db.py\n+++ b/django/core/cache/backends/db.py\n@@ -267,9 +267,11 @@\n                 cursor.execute(\n                     connection.ops.cache_key_culling_sql() % table,\n                     [cull_num])\n-                cursor.execute(\"DELETE FROM %s \"\n-                               \"WHERE cache_key < %%s\" % table,\n-                               [cursor.fetchone()[0]])\n+                result = cursor.fetchone()\n+                if result is not None:\n+                    cursor.execute(\"DELETE FROM %s \"\n+                                   \"WHERE cache_key < %%s\" % table,\n+                                   [result[0]])\n \n     def clear(self):\n         db = router.db_for_write(self.cache_model_class)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13109", "model_patch": "--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -914,7 +914,7 @@\n             return\n \n         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n-        qs = self.remote_field.model._default_manager.using(using).filter(\n+        qs = self.remote_field.model._base_manager.using(using).filter(\n             **{self.remote_field.field_name: value}\n         )\n         qs = qs.complex_filter(self.get_limit_choices_to())\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13112", "model_patch": "--- a/django/db/models/utils.py\n+++ b/django/db/models/utils.py\n@@ -9,7 +9,7 @@\n             model_tuple = model\n         elif isinstance(model, str):\n             app_label, model_name = model.split(\".\")\n-            model_tuple = app_label, model_name.lower()\n+            model_tuple = app_label.lower(), model_name.lower()\n         else:\n             model_tuple = model._meta.app_label, model._meta.model_name\n         assert len(model_tuple) == 2\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13121", "model_patch": "--- a/django/db/backends/sqlite3/operations.py\n+++ b/django/db/backends/sqlite3/operations.py\n@@ -321,6 +321,33 @@\n     def convert_booleanfield_value(self, value, expression, connection):\n         return bool(value) if value in (1, 0) else value\n \n+    def convert_durationfield_value(self, value, expression, connection):\n+        if value is not None:\n+            # SQLite duration arithmetic returns values in different formats\n+            # Handle the case where value is already a timedelta\n+            if isinstance(value, datetime.timedelta):\n+                return value\n+            # Handle string values that might be returned by SQLite custom functions\n+            if isinstance(value, str):\n+                try:\n+                    # Try to parse as a decimal string representing microseconds\n+                    microseconds = decimal.Decimal(value)\n+                    return datetime.timedelta(microseconds=float(microseconds))\n+                except (decimal.InvalidOperation, ValueError):\n+                    # If that fails, try to parse as a duration string\n+                    try:\n+                        # Handle duration strings like \"1 day, 0:00:00\" or \"0:00:01\"\n+                        return datetime.timedelta(seconds=float(value))\n+                    except (ValueError, TypeError):\n+                        # If all parsing fails, return the original value\n+                        return value\n+            # Handle numeric values (microseconds)\n+            try:\n+                return datetime.timedelta(microseconds=float(value))\n+            except (ValueError, TypeError):\n+                pass\n+        return value\n+\n     def bulk_insert_sql(self, fields, placeholder_rows):\n         return \" UNION ALL \".join(\n             \"SELECT %s\" % \", \".join(row)\n\n--- a/django/db/backends/mysql/operations.py\n+++ b/django/db/backends/mysql/operations.py\n@@ -315,6 +315,27 @@\n             value = uuid.UUID(value)\n         return value\n \n+    def convert_durationfield_value(self, value, expression, connection):\n+        if value is not None:\n+            # Handle the case where value is already a timedelta\n+            if isinstance(value, datetime.timedelta):\n+                return value\n+            # Handle string values that might be returned by MySQL duration arithmetic\n+            if isinstance(value, str):\n+                try:\n+                    # Try to parse as a decimal string representing microseconds\n+                    microseconds = decimal.Decimal(value)\n+                    return datetime.timedelta(microseconds=float(microseconds))\n+                except (decimal.InvalidOperation, ValueError):\n+                    # Handle INTERVAL format strings if needed\n+                    return value\n+            # Handle numeric values (microseconds)\n+            try:\n+                return datetime.timedelta(microseconds=float(value))\n+            except (ValueError, TypeError):\n+                pass\n+        return value\n+\n     def binary_placeholder_sql(self, value):\n         return '_binary %s' if value is not None and not hasattr(value, 'as_sql') else '%s'\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13128", "model_patch": "--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -298,7 +298,24 @@\n         If all sources are None, then an error is raised higher up the stack in\n         the output_field property.\n         \"\"\"\n-        sources_iter = (source for source in self.get_source_fields() if source is not None)\n+        sources = [source for source in self.get_source_fields() if source is not None]\n+        \n+        # Special handling for temporal arithmetic operations\n+        # Check if this is a subtraction operation between DateTimeFields\n+        if (hasattr(self, 'connector') and self.connector == '-' and \n+            len(sources) == 2 and \n+            all(isinstance(source, fields.DateTimeField) for source in sources)):\n+            return fields.DurationField()\n+        \n+        # Check for mixed DateTimeField and DurationField in addition/subtraction\n+        if (hasattr(self, 'connector') and self.connector in ['+', '-'] and \n+            len(sources) == 2):\n+            datetime_fields = [s for s in sources if isinstance(s, fields.DateTimeField)]\n+            duration_fields = [s for s in sources if isinstance(s, fields.DurationField)]\n+            if len(datetime_fields) == 1 and len(duration_fields) == 1:\n+                return fields.DateTimeField()\n+        \n+        sources_iter = (source for source in sources)\n         for output_field in sources_iter:\n             for source in sources_iter:\n                 if not isinstance(output_field, source.__class__):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13158", "model_patch": "--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -431,6 +431,9 @@\n         return sql, params\n \n     def get_combinator_sql(self, combinator, all):\n+        # Check if the main query is empty (contains NothingNode)\n+        if self.query.is_empty():\n+            raise EmptyResultSet\n         features = self.connection.features\n         compilers = [\n             query.get_compiler(self.using, self.connection)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13195", "model_patch": "--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -210,13 +210,13 @@\n         value = signing.get_cookie_signer(salt=key + salt).sign(value)\n         return self.set_cookie(key, value, **kwargs)\n \n-    def delete_cookie(self, key, path='/', domain=None):\n+    def delete_cookie(self, key, path='/', domain=None, samesite=None):\n         # Most browsers ignore the Set-Cookie header if the cookie name starts\n         # with __Host- or __Secure- and the cookie doesn't use the secure flag.\n         secure = key.startswith(('__Secure-', '__Host-'))\n         self.set_cookie(\n             key, max_age=0, path=path, domain=domain, secure=secure,\n-            expires='Thu, 01 Jan 1970 00:00:00 GMT',\n+            expires='Thu, 01 Jan 1970 00:00:00 GMT', samesite=samesite,\n         )\n \n     # Common methods used by subclasses\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13279", "model_patch": "--- a/django/contrib/sessions/backends/base.py\n+++ b/django/contrib/sessions/backends/base.py\n@@ -106,8 +106,18 @@\n         key_salt = \"django.contrib.sessions\" + self.__class__.__name__\n         return salted_hmac(key_salt, value).hexdigest()\n \n+    def legacy_encode(self, session_dict):\n+        \"Return the given session dictionary serialized and encoded as a string using the pre-Django 3.1 format.\"\n+        # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.\n+        serialized = self.serializer().dumps(session_dict)\n+        hash = self._hash(serialized)\n+        encoded_data = base64.b64encode(hash.encode('ascii') + b':' + serialized)\n+        return encoded_data.decode('ascii')\n+\n     def encode(self, session_dict):\n         \"Return the given session dictionary serialized and encoded as a string.\"\n+        if settings.DEFAULT_HASHING_ALGORITHM == 'sha1':\n+            return self.legacy_encode(session_dict)\n         return signing.dumps(\n             session_dict, salt=self.key_salt, serializer=self.serializer,\n             compress=True,\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13297", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -21,7 +21,7 @@\n     parse_date, parse_datetime, parse_duration, parse_time,\n )\n from django.utils.duration import duration_microseconds, duration_string\n-from django.utils.functional import Promise, cached_property\n+from django.utils.functional import Promise, SimpleLazyObject, cached_property\n from django.utils.ipv6 import clean_ipv6_address\n from django.utils.itercompat import is_iterable\n from django.utils.text import capfirst\n@@ -806,6 +806,8 @@\n         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n         if isinstance(value, Promise):\n             value = value._proxy____cast()\n+        elif isinstance(value, SimpleLazyObject):\n+            value = value._wrapped if value._wrapped is not SimpleLazyObject.empty else value()\n         return value\n \n     def get_db_prep_value(self, value, connection, prepared=False):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13315", "model_patch": "--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -978,7 +978,7 @@\n         if isinstance(filter_obj, Q):\n             clone = self._chain()\n             clone.query.add_q(filter_obj)\n-            return clone\n+            return clone.distinct()\n         else:\n             return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13343", "model_patch": "--- a/django/db/models/fields/files.py\n+++ b/django/db/models/fields/files.py\n@@ -227,7 +227,9 @@\n     def __init__(self, verbose_name=None, name=None, upload_to='', storage=None, **kwargs):\n         self._primary_key_set_explicitly = 'primary_key' in kwargs\n \n-        self.storage = storage or default_storage\n+        # Store the original storage parameter for deconstruction\n+        self._storage = storage or default_storage\n+        self.storage = self._storage\n         if callable(self.storage):\n             self.storage = self.storage()\n             if not isinstance(self.storage, Storage):\n@@ -278,8 +280,8 @@\n         if kwargs.get(\"max_length\") == 100:\n             del kwargs[\"max_length\"]\n         kwargs['upload_to'] = self.upload_to\n-        if self.storage is not default_storage:\n-            kwargs['storage'] = self.storage\n+        if self._storage is not default_storage:\n+            kwargs['storage'] = self._storage\n         return name, path, args, kwargs\n \n     def get_internal_type(self):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13344", "model_patch": "--- a/django/utils/deprecation.py\n+++ b/django/utils/deprecation.py\n@@ -131,6 +131,9 @@\n                 thread_sensitive=True,\n             )(request)\n         response = response or await self.get_response(request)\n+        # Ensure response is not a coroutine before passing to process_response\n+        if asyncio.iscoroutine(response):\n+            response = await response\n         if hasattr(self, 'process_response'):\n             response = await sync_to_async(\n                 self.process_response,\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13346", "model_patch": "--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -455,6 +455,10 @@\n     pass\n \n \n+class KeyTransformIn(KeyTransformTextLookupMixin, lookups.In):\n+    pass\n+\n+\n class KeyTransformNumericLookupMixin:\n     def process_rhs(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13363", "model_patch": "--- a/django/db/models/functions/datetime.py\n+++ b/django/db/models/functions/datetime.py\n@@ -292,7 +292,7 @@\n     def as_sql(self, compiler, connection):\n         # Cast to date rather than truncate to date.\n         lhs, lhs_params = compiler.compile(self.lhs)\n-        tzname = timezone.get_current_timezone_name() if settings.USE_TZ else None\n+        tzname = self.get_tzname()\n         sql = connection.ops.datetime_cast_date_sql(lhs, tzname)\n         return sql, lhs_params\n \n@@ -305,7 +305,7 @@\n     def as_sql(self, compiler, connection):\n         # Cast to time rather than truncate to time.\n         lhs, lhs_params = compiler.compile(self.lhs)\n-        tzname = timezone.get_current_timezone_name() if settings.USE_TZ else None\n+        tzname = self.get_tzname()\n         sql = connection.ops.datetime_cast_time_sql(lhs, tzname)\n         return sql, lhs_params\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13401", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -516,16 +516,44 @@\n     def __eq__(self, other):\n         # Needed for @total_ordering\n         if isinstance(other, Field):\n-            return self.creation_counter == other.creation_counter\n+            if self.creation_counter != other.creation_counter:\n+                return False\n+            # If both fields have models, they must be the same model\n+            if hasattr(self, 'model') and hasattr(other, 'model'):\n+                return self.model == other.model\n+            # If only one has a model, they're not equal\n+            elif hasattr(self, 'model') or hasattr(other, 'model'):\n+                return False\n+            # If neither has a model, they're equal (based on creation_counter)\n+            return True\n         return NotImplemented\n \n     def __lt__(self, other):\n         # This is needed because bisect does not take a comparison function.\n         if isinstance(other, Field):\n-            return self.creation_counter < other.creation_counter\n+            if self.creation_counter != other.creation_counter:\n+                return self.creation_counter < other.creation_counter\n+            # Use model as tiebreaker when creation_counters are equal\n+            self_model = getattr(self, 'model', None)\n+            other_model = getattr(other, 'model', None)\n+            if self_model is not None and other_model is not None:\n+                # Compare by model name for consistent ordering\n+                self_model_name = f\"{self_model._meta.app_label}.{self_model._meta.model_name}\"\n+                other_model_name = f\"{other_model._meta.app_label}.{other_model._meta.model_name}\"\n+                return self_model_name < other_model_name\n+            elif self_model is None and other_model is not None:\n+                return True  # Fields without model come first\n+            elif self_model is not None and other_model is None:\n+                return False  # Fields with model come after\n+            # Both have no model, they're equal in ordering\n+            return False\n         return NotImplemented\n \n     def __hash__(self):\n+        model = getattr(self, 'model', None)\n+        if model is not None:\n+            model_key = (model._meta.app_label, model._meta.model_name)\n+            return hash((self.creation_counter, model_key))\n         return hash(self.creation_counter)\n \n     def __deepcopy__(self, memodict):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13406", "model_patch": "--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -195,7 +195,11 @@\n         self._prefetch_related_lookups = ()\n         self._prefetch_done = False\n         self._known_related_objects = {}  # {rel_field: {pk: rel_obj}}\n-        self._iterable_class = ModelIterable\n+        # Automatically detect if this is a values() query and set appropriate iterable class\n+        if self._query.values_select:\n+            self._iterable_class = ValuesIterable\n+        else:\n+            self._iterable_class = ModelIterable\n         self._fields = None\n         self._defer_next_filter = False\n         self._deferred_filter = None\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13410", "model_patch": "--- a/django/core/files/locks.py\n+++ b/django/core/files/locks.py\n@@ -107,9 +107,15 @@\n             return True\n     else:\n         def lock(f, flags):\n-            ret = fcntl.flock(_fd(f), flags)\n-            return ret == 0\n+            try:\n+                fcntl.flock(_fd(f), flags)\n+                return True\n+            except OSError:\n+                return False\n \n         def unlock(f):\n-            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n-            return ret == 0\n+            try:\n+                fcntl.flock(_fd(f), fcntl.LOCK_UN)\n+                return True\n+            except OSError:\n+                return False\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13417", "model_patch": "--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1225,6 +1225,10 @@\n         if self.query.extra_order_by or self.query.order_by:\n             return True\n         elif self.query.default_ordering and self.query.get_meta().ordering:\n+            # If GROUP BY is active but there are no explicit ORDER BY clauses,\n+            # the default ordering will be stripped out, so results won't be ordered\n+            if self.query.group_by is not None:\n+                return False\n             return True\n         else:\n             return False\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13449", "model_patch": "--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1253,7 +1253,7 @@\n         self.descending = True\n \n \n-class Window(Expression):\n+class Window(SQLiteNumericMixin, Expression):\n     template = '%(expression)s OVER (%(window)s)'\n     # Although the main expression may either be an aggregate or an\n     # expression with an aggregate function, the GROUP BY that will\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13512", "model_patch": "--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1258,7 +1258,7 @@\n     def prepare_value(self, value):\n         if isinstance(value, InvalidJSONInput):\n             return value\n-        return json.dumps(value, cls=self.encoder)\n+        return json.dumps(value, cls=self.encoder, ensure_ascii=False)\n \n     def has_changed(self, initial, data):\n         if super().has_changed(initial, data):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13516", "model_patch": "--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -149,6 +149,10 @@\n             msg += ending\n         style_func = style_func or self.style_func\n         self._out.write(style_func(msg))\n+\n+    def flush(self):\n+        if hasattr(self._out, 'flush'):\n+            self._out.flush()\n \n \n class BaseCommand:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13551", "model_patch": "--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -94,7 +94,7 @@\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + str(getattr(user, 'email', '') or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13568", "model_patch": "--- a/django/contrib/auth/checks.py\n+++ b/django/contrib/auth/checks.py\n@@ -4,6 +4,7 @@\n from django.apps import apps\n from django.conf import settings\n from django.core import checks\n+from django.db.models.constraints import UniqueConstraint\n \n from .management import _get_builtin_permissions\n \n@@ -52,7 +53,13 @@\n         )\n \n     # Check that the username field is unique\n-    if not cls._meta.get_field(cls.USERNAME_FIELD).unique:\n+    field_unique = cls._meta.get_field(cls.USERNAME_FIELD).unique\n+    # Also check if USERNAME_FIELD is covered by any UniqueConstraint\n+    constraint_unique = any(\n+        isinstance(constraint, UniqueConstraint) and cls.USERNAME_FIELD in constraint.fields\n+        for constraint in cls._meta.constraints\n+    )\n+    if not (field_unique or constraint_unique):\n         if (settings.AUTHENTICATION_BACKENDS ==\n                 ['django.contrib.auth.backends.ModelBackend']):\n             errors.append(\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13569", "model_patch": "--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -129,7 +129,10 @@\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+                expressions.extend([\n+                    exp for exp in expr.get_group_by_cols()\n+                    if not isinstance(exp, Random)\n+                ])\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13590", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1077,10 +1077,10 @@\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            return type(value)(*(\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n-            )\n+            ))\n         return value\n \n     def solve_lookup_type(self, lookup):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13658", "model_patch": "--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -344,7 +344,7 @@\n         # Preprocess options to extract --settings and --pythonpath.\n         # These options could affect the commands that are available, so they\n         # must be processed early.\n-        parser = CommandParser(usage='%(prog)s subcommand [options] [args]', add_help=False, allow_abbrev=False)\n+        parser = CommandParser(prog=self.prog_name, usage='%(prog)s subcommand [options] [args]', add_help=False, allow_abbrev=False)\n         parser.add_argument('--settings')\n         parser.add_argument('--pythonpath')\n         parser.add_argument('args', nargs='*')  # catch-all\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13670", "model_patch": "--- a/django/utils/dateformat.py\n+++ b/django/utils/dateformat.py\n@@ -326,7 +326,7 @@\n \n     def y(self):\n         \"Year, 2 digits; e.g. '99'\"\n-        return str(self.data.year)[2:]\n+        return '%02d' % (self.data.year % 100)\n \n     def Y(self):\n         \"Year, 4 digits; e.g. '1999'\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13741", "model_patch": "--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -56,6 +56,7 @@\n \n     def __init__(self, *args, **kwargs):\n         kwargs.setdefault(\"required\", False)\n+        kwargs.setdefault('disabled', True)\n         super().__init__(*args, **kwargs)\n \n     def bound_data(self, data, initial):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13786", "model_patch": "--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -137,11 +137,17 @@\n                 ),\n             ]\n         elif isinstance(operation, AlterModelOptions) and self.name_lower == operation.name_lower:\n+            # Merge options but also remove options that should be cleared\n+            options = {**self.options, **operation.options}\n+            # Remove options from ALTER_OPTION_KEYS that are not present in operation.options\n+            for key in operation.ALTER_OPTION_KEYS:\n+                if key not in operation.options:\n+                    options.pop(key, None)\n             return [\n                 CreateModel(\n                     self.name,\n                     fields=self.fields,\n-                    options={**self.options, **operation.options},\n+                    options=options,\n                     bases=self.bases,\n                     managers=self.managers,\n                 ),\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13794", "model_patch": "--- a/django/template/defaultfilters.py\n+++ b/django/template/defaultfilters.py\n@@ -11,6 +11,7 @@\n from django.utils import formats\n from django.utils.dateformat import format, time_format\n from django.utils.encoding import iri_to_uri\n+from django.utils.functional import keep_lazy_text\n from django.utils.html import (\n     avoid_wrapping, conditional_escape, escape, escapejs,\n     json_script as _json_script, linebreaks, strip_tags, urlize as _urlize,\n@@ -671,6 +672,7 @@\n # INTEGERS        #\n ###################\n \n+@keep_lazy_text\n @register.filter(is_safe=False)\n def add(value, arg):\n     \"\"\"Add the arg to the value.\"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13807", "model_patch": "--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -327,19 +327,19 @@\n                     violations = cursor.execute('PRAGMA foreign_key_check').fetchall()\n                 else:\n                     violations = chain.from_iterable(\n-                        cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()\n+                        cursor.execute('PRAGMA foreign_key_check(%s)' % self.ops.quote_name(table_name)).fetchall()\n                         for table_name in table_names\n                     )\n                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n                     foreign_key = cursor.execute(\n-                        'PRAGMA foreign_key_list(%s)' % table_name\n+                        'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)\n                     ).fetchall()[foreign_key_index]\n                     column_name, referenced_column_name = foreign_key[3:5]\n                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n                     primary_key_value, bad_value = cursor.execute(\n                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n-                            primary_key_column_name, column_name, table_name\n+                            self.ops.quote_name(primary_key_column_name), self.ops.quote_name(column_name), self.ops.quote_name(table_name)\n                         ),\n                         (rowid,),\n                     ).fetchone()\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13809", "model_patch": "--- a/django/core/management/commands/runserver.py\n+++ b/django/core/management/commands/runserver.py\n@@ -50,6 +50,10 @@\n         parser.add_argument(\n             '--noreload', action='store_false', dest='use_reloader',\n             help='Tells Django to NOT use the auto-reloader.',\n+        )\n+        parser.add_argument(\n+            '--skip-checks', action='store_true', dest='skip_checks',\n+            help='Skip system checks.',\n         )\n \n     def execute(self, *args, **options):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13810", "model_patch": "--- a/django/core/handlers/base.py\n+++ b/django/core/handlers/base.py\n@@ -49,6 +49,9 @@\n                 middleware_is_async = False\n             else:\n                 middleware_is_async = middleware_can_async\n+            # Store original handler state before trying to adapt it\n+            original_handler = handler\n+            original_handler_is_async = handler_is_async\n             try:\n                 # Adapt handler, if needed.\n                 handler = self.adapt_method_mode(\n@@ -57,6 +60,9 @@\n                 )\n                 mw_instance = middleware(handler)\n             except MiddlewareNotUsed as exc:\n+                # Restore original handler state to avoid poisoning the middleware chain\n+                handler = original_handler\n+                handler_is_async = original_handler_is_async\n                 if settings.DEBUG:\n                     if str(exc):\n                         logger.debug('MiddlewareNotUsed(%r): %s', middleware_path, exc)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13820", "model_patch": "--- a/django/db/migrations/loader.py\n+++ b/django/db/migrations/loader.py\n@@ -90,7 +90,7 @@\n             else:\n                 # Empty directories are namespaces.\n                 # getattr() needed on PY36 and older (replace w/attribute access).\n-                if getattr(module, '__file__', None) is None:\n+                if getattr(module, '__file__', None) is None and not isinstance(module.__path__, list):\n                     self.unmigrated_apps.add(app_config.label)\n                     continue\n                 # Module is not a package (e.g. migrations.py).\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13821", "model_patch": "--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -64,8 +64,8 @@\n \n \n def check_sqlite_version():\n-    if Database.sqlite_version_info < (3, 8, 3):\n-        raise ImproperlyConfigured('SQLite 3.8.3 or later is required (found %s).' % Database.sqlite_version)\n+    if Database.sqlite_version_info < (3, 9, 0):\n+        raise ImproperlyConfigured('SQLite 3.9.0 or later is required (found %s).' % Database.sqlite_version)\n \n \n check_sqlite_version()\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13837", "model_patch": "--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -216,14 +216,14 @@\n     executable is reported to not have the .exe extension which can cause bugs\n     on reloading.\n     \"\"\"\n-    import django.__main__\n-    django_main_path = Path(django.__main__.__file__)\n     py_script = Path(sys.argv[0])\n \n     args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n-    if py_script == django_main_path:\n-        # The server was started with `python -m django runserver`.\n-        args += ['-m', 'django']\n+    # Check if Python was launched with -m by examining __main__.__spec__\n+    import __main__\n+    if getattr(__main__, '__spec__', None) is not None and getattr(__main__.__spec__, 'parent', None):\n+        # The server was started with `python -m <package> runserver`.\n+        args += ['-m', __main__.__spec__.parent]\n         args += sys.argv[1:]\n     elif not py_script.exists():\n         # sys.argv[0] may not exist for several reasons on Windows.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13925", "model_patch": "--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -275,6 +275,9 @@\n                             field.name not in new_class.__dict__ and\n                             field.name not in inherited_attributes):\n                         new_field = copy.deepcopy(field)\n+                        # Preserve the original auto_created value when copying fields\n+                        # from abstract base classes to prevent false positive W042 warnings\n+                        new_field.auto_created = field.auto_created\n                         new_class.add_to_class(field.name, new_field)\n                         # Replace parent links defined on this base by the new\n                         # field. It will be appropriately resolved if required.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13933", "model_patch": "--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1188,7 +1188,7 @@\n     # This class is a subclass of ChoiceField for purity, but it doesn't\n     # actually use any of ChoiceField's implementation.\n     default_error_messages = {\n-        'invalid_choice': _('Select a valid choice. That choice is not one of'\n+        'invalid_choice': _('Select a valid choice. %(value)s is not one of'\n                             ' the available choices.'),\n     }\n     iterator = ModelChoiceIterator\n@@ -1284,7 +1284,7 @@\n                 value = getattr(value, key)\n             value = self.queryset.get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n-            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n+            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice', params={'value': value})\n         return value\n \n     def validate(self, value):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-13964", "model_patch": "--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -933,7 +933,7 @@\n                         \"%s() prohibited to prevent data loss due to unsaved \"\n                         \"related object '%s'.\" % (operation_name, field.name)\n                     )\n-                elif getattr(self, field.attname) is None:\n+                elif getattr(self, field.attname) is None or getattr(self, field.attname) == '':\n                     # Use pk from related object if it has been saved after\n                     # an assignment.\n                     setattr(self, field.attname, obj.pk)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14007", "model_patch": "--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -505,6 +505,9 @@\n                 for obj_with_pk, results in zip(objs_with_pk, returned_columns):\n                     for result, field in zip(results, opts.db_returning_fields):\n                         if field != opts.pk:\n+                            # Apply field conversion using from_db_value for consistency with SELECT queries\n+                            if hasattr(field, 'from_db_value'):\n+                                result = field.from_db_value(result, None, self.db)\n                             setattr(obj_with_pk, field.attname, result)\n                 for obj_with_pk in objs_with_pk:\n                     obj_with_pk._state.adding = False\n@@ -518,6 +521,9 @@\n                     assert len(returned_columns) == len(objs_without_pk)\n                 for obj_without_pk, results in zip(objs_without_pk, returned_columns):\n                     for result, field in zip(results, opts.db_returning_fields):\n+                        # Apply field conversion using from_db_value for consistency with SELECT queries\n+                        if hasattr(field, 'from_db_value'):\n+                            result = field.from_db_value(result, None, self.db)\n                         setattr(obj_without_pk, field.attname, result)\n                     obj_without_pk._state.adding = False\n                     obj_without_pk._state.db = self.db\n\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -872,6 +872,9 @@\n             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)\n             if results:\n                 for value, field in zip(results[0], returning_fields):\n+                    # Apply field conversion using from_db_value for consistency with SELECT queries\n+                    if hasattr(field, 'from_db_value'):\n+                        value = field.from_db_value(value, None, using)\n                     setattr(self, field.attname, value)\n         return updated\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14011", "model_patch": "--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -80,6 +80,32 @@\n class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n     \"\"\"A threaded version of the WSGIServer\"\"\"\n     daemon_threads = True\n+\n+    def process_request(self, request, client_address):\n+        \"\"\"Start a new thread to process the request.\"\"\"\n+        from django.db import connections\n+        \n+        def process_request_thread(request, client_address):\n+            \"\"\"Same as in BaseServer but as a thread.\n+            \n+            In addition to the BaseServer implementation, this function\n+            closes database connections after processing the request to\n+            prevent connection leaks in threaded environments.\n+            \"\"\"\n+            try:\n+                self.finish_request(request, client_address)\n+            except Exception:\n+                self.handle_error(request, client_address)\n+            finally:\n+                # Close database connections to prevent leaks\n+                connections.close_all()\n+                self.shutdown_request(request)\n+        \n+        import threading\n+        t = threading.Thread(target=process_request_thread,\n+                           args=(request, client_address))\n+        t.daemon = self.daemon_threads\n+        t.start()\n \n \n class ServerHandler(simple_server.ServerHandler):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14017", "model_patch": "--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -11,6 +11,7 @@\n \n from django.core.exceptions import FieldError\n from django.db.models.constants import LOOKUP_SEP\n+from django.db.models.expressions import Expression\n from django.utils import tree\n \n # PathInfo is used when converting lookups (fk__somecol). The contents\n@@ -40,7 +41,7 @@\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n+        if not isinstance(other, (Q, Expression)):\n             raise TypeError(other)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -137,6 +137,8 @@\n         return self._combine(other, self.POW, True)\n \n     def __rand__(self, other):\n+        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n+            return Q(other) & Q(self)\n         raise NotImplementedError(\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14034", "model_patch": "--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1025,8 +1025,16 @@\n             if not value or not [v for v in value if v not in self.empty_values]:\n                 if self.required:\n                     raise ValidationError(self.error_messages['required'], code='required')\n-                else:\n-                    return self.compress([])\n+                elif not self.require_all_fields:\n+                    # Check individual field requirements even when all values are empty\n+                    errors = []\n+                    for i, field in enumerate(self.fields):\n+                        if field.required:\n+                            if field.error_messages['incomplete'] not in errors:\n+                                errors.append(field.error_messages['incomplete'])\n+                    if errors:\n+                        raise ValidationError(errors)\n+                return self.compress([])\n         else:\n             raise ValidationError(self.error_messages['invalid'], code='invalid')\n         for i, field in enumerate(self.fields):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14053", "model_patch": "--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -220,6 +220,8 @@\n \n         # where to store the new paths\n         hashed_files = {}\n+        # track yielded files to prevent duplicates\n+        yielded_files = {}\n \n         # build a list of adjustable files\n         adjustable_paths = [\n@@ -229,14 +231,20 @@\n         # Do a single pass first. Post-process all files once, then repeat for\n         # adjustable files.\n         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):\n-            yield name, hashed_name, processed\n+            # Only yield if we haven't yielded this file before or if the hashed_name changed\n+            if name not in yielded_files or yielded_files[name] != hashed_name:\n+                yielded_files[name] = hashed_name\n+                yield name, hashed_name, processed\n \n         paths = {path: paths[path] for path in adjustable_paths}\n \n         for i in range(self.max_post_process_passes):\n             substitutions = False\n             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n-                yield name, hashed_name, processed\n+                # Only yield if we haven't yielded this file before or if the hashed_name changed\n+                if name not in yielded_files or yielded_files[name] != hashed_name:\n+                    yielded_files[name] = hashed_name\n+                    yield name, hashed_name, processed\n                 substitutions = substitutions or subst\n \n             if not substitutions:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14089", "model_patch": "--- a/django/utils/datastructures.py\n+++ b/django/utils/datastructures.py\n@@ -24,6 +24,9 @@\n \n     def __iter__(self):\n         return iter(self.dict)\n+\n+    def __reversed__(self):\n+        return reversed(self.dict)\n \n     def __contains__(self, item):\n         return item in self.dict\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14122", "model_patch": "--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -129,7 +129,10 @@\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+                # Skip adding order_by expressions to GROUP BY when Meta.ordering is being used,\n+                # since Meta.ordering should not affect aggregation results.\n+                if not (hasattr(self, '_meta_ordering') and self._meta_ordering):\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14140", "model_patch": "--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -87,7 +87,10 @@\n         args, kwargs = (), {}\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n-            kwargs = {child[0]: child[1]}\n+            if isinstance(child, (tuple, list)) and len(child) == 2:\n+                kwargs = {child[0]: child[1]}\n+            else:\n+                args = tuple(self.children)\n         else:\n             args = tuple(self.children)\n             if self.connector != self.default:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14155", "model_patch": "--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -31,9 +31,19 @@\n \n class ResolverMatch:\n     def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n-        self.func = func\n-        self.args = args\n-        self.kwargs = kwargs\n+        # Handle functools.partial objects by unwrapping them\n+        if isinstance(func, functools.partial):\n+            # Merge partial's args with provided args (partial args take precedence at the beginning)\n+            merged_args = func.args + args\n+            # Merge partial's kwargs with provided kwargs (partial kwargs take precedence)\n+            merged_kwargs = {**kwargs, **func.keywords}\n+            self.func = func.func\n+            self.args = merged_args\n+            self.kwargs = merged_kwargs\n+        else:\n+            self.func = func\n+            self.args = args\n+            self.kwargs = kwargs\n         self.url_name = url_name\n         self.route = route\n         self.tried = tried\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14170", "model_patch": "--- a/django/db/models/functions/datetime.py\n+++ b/django/db/models/functions/datetime.py\n@@ -164,11 +164,7 @@\n ExtractYear.register_lookup(YearLt)\n ExtractYear.register_lookup(YearLte)\n \n-ExtractIsoYear.register_lookup(YearExact)\n-ExtractIsoYear.register_lookup(YearGt)\n-ExtractIsoYear.register_lookup(YearGte)\n-ExtractIsoYear.register_lookup(YearLt)\n-ExtractIsoYear.register_lookup(YearLte)\n+\n \n \n class Now(Func):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14238", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2524,7 +2524,7 @@\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14311", "model_patch": "--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -224,7 +224,7 @@\n     # see https://docs.python.org/3/reference/import.html#main-spec\n     # __spec__ may not exist, e.g. when running in a Conda env.\n     if getattr(__main__, '__spec__', None) is not None and __main__.__spec__.parent:\n-        args += ['-m', __main__.__spec__.parent]\n+        args += ['-m', __main__.__spec__.name]\n         args += sys.argv[1:]\n     elif not py_script.exists():\n         # sys.argv[0] may not exist for several reasons on Windows.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14315", "model_patch": "--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -51,7 +51,7 @@\n             env['PGSSLKEY'] = str(sslkey)\n         if passfile:\n             env['PGPASSFILE'] = str(passfile)\n-        return args, env\n+        return args, env or None\n \n     def runshell(self, parameters):\n         sigint_handler = signal.getsignal(signal.SIGINT)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14349", "model_patch": "--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -100,6 +100,10 @@\n \n     def __call__(self, value):\n         if not isinstance(value, str):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n+        # Check for forbidden characters (LF, CR, tab) early to ensure compatibility\n+        # with Python versions that have the bpo-43882 fix\n+        if '\\n' in value or '\\r' in value or '\\t' in value:\n             raise ValidationError(self.message, code=self.code, params={'value': value})\n         # Check if the scheme is valid.\n         scheme = value.split('://')[0].lower()\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14351", "model_patch": "--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -98,6 +98,23 @@\n                 else:\n                     target_field = self.lhs.field.target_field.name\n                 self.rhs.add_fields([target_field], True)\n+            elif (getattr(self.rhs, 'has_select_fields', True) and\n+                  getattr(self.rhs, 'default_cols', False) and\n+                  not getattr(self.lhs.field.target_field, 'primary_key', False)):\n+                # Handle the case when has_select_fields is True but we still need to\n+                # limit the subquery to select only the required field. This happens\n+                # when a QuerySet is used in a RelatedIn lookup and it has default\n+                # columns selected, which can cause \"subquery must return only one column\" errors.\n+                self.rhs.clear_select_clause()\n+                if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                        self.lhs.output_field.model == self.rhs.model):\n+                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n+                    # where place is a OneToOneField and the primary key of\n+                    # Restaurant.\n+                    target_field = self.lhs.field.name\n+                else:\n+                    target_field = self.lhs.field.target_field.name\n+                self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n \n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14373", "model_patch": "--- a/django/utils/dateformat.py\n+++ b/django/utils/dateformat.py\n@@ -314,7 +314,7 @@\n \n     def Y(self):\n         \"Year, 4 digits; e.g. '1999'\"\n-        return self.data.year\n+        return '%04d' % self.data.year\n \n     def z(self):\n         \"\"\"Day of the year, i.e. 1 to 366.\"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14376", "model_patch": "--- a/django/db/backends/mysql/base.py\n+++ b/django/db/backends/mysql/base.py\n@@ -200,9 +200,9 @@\n         if settings_dict['USER']:\n             kwargs['user'] = settings_dict['USER']\n         if settings_dict['NAME']:\n-            kwargs['db'] = settings_dict['NAME']\n+            kwargs['database'] = settings_dict['NAME']\n         if settings_dict['PASSWORD']:\n-            kwargs['passwd'] = settings_dict['PASSWORD']\n+            kwargs['password'] = settings_dict['PASSWORD']\n         if settings_dict['HOST'].startswith('/'):\n             kwargs['unix_socket'] = settings_dict['HOST']\n         elif settings_dict['HOST']:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14404", "model_patch": "--- a/django/contrib/admin/sites.py\n+++ b/django/contrib/admin/sites.py\n@@ -420,7 +420,7 @@\n     def catch_all_view(self, request, url):\n         if settings.APPEND_SLASH and not url.endswith('/'):\n             urlconf = getattr(request, 'urlconf', None)\n-            path = '%s/' % request.path_info\n+            path = '%s/' % request.path\n             try:\n                 match = resolve(path, urlconf)\n             except Resolver404:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14434", "model_patch": "--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1251,7 +1251,7 @@\n         else:\n             sql = self.sql_create_unique\n         if columns:\n-            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n+            columns = self._index_columns(table.table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n             columns = Expressions(model._meta.db_table, expressions, compiler, self.quote_value)\n         return Statement(\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14493", "model_patch": "--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -261,8 +261,8 @@\n \n         paths = {path: paths[path] for path in adjustable_paths}\n \n+        substitutions = False\n         for i in range(self.max_post_process_passes):\n-            substitutions = False\n             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n                 # Overwrite since hashed_name may be newer.\n                 processed_adjustable_paths[name] = (name, hashed_name, processed)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14500", "model_patch": "--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -254,6 +254,13 @@\n         if migration.replaces:\n             for app_label, name in migration.replaces:\n                 self.recorder.record_unapplied(app_label, name)\n+            # Only mark the squash migration as unapplied if the replaced migration files are NOT present\n+            replaced_migrations_exist = any(\n+                (app_label, name) in self.loader.disk_migrations\n+                for app_label, name in migration.replaces\n+            )\n+            if not replaced_migrations_exist:\n+                self.recorder.record_unapplied(migration.app_label, migration.name)\n         else:\n             self.recorder.record_unapplied(migration.app_label, migration.name)\n         # Report progress\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14534", "model_patch": "--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -277,7 +277,7 @@\n \n     @property\n     def id_for_label(self):\n-        return 'id_%s_%s' % (self.data['name'], self.data['index'])\n+        return self.data['attrs']['id']\n \n     @property\n     def choice_label(self):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14539", "model_patch": "--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -283,8 +283,11 @@\n             middle_unescaped = html.unescape(middle)\n             stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)\n             if middle_unescaped != stripped:\n-                trail = middle[len(stripped):] + trail\n-                middle = middle[:len(stripped) - len(middle_unescaped)]\n+                # Calculate how many characters were stripped from the unescaped version\n+                chars_stripped = len(middle_unescaped) - len(stripped)\n+                # Find the corresponding position in the original escaped string\n+                trail = middle[len(middle) - chars_stripped:] + trail\n+                middle = middle[:len(middle) - chars_stripped]\n                 trimmed_something = True\n         return lead, middle, trail\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14559", "model_patch": "--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,7 @@\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +563,11 @@\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+        rows_updated = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                rows_updated += self.filter(pk__in=pks).update(**update_kwargs)\n+        return rows_updated\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14580", "model_patch": "--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -273,7 +273,7 @@\n class TypeSerializer(BaseSerializer):\n     def serialize(self):\n         special_cases = [\n-            (models.Model, \"models.Model\", []),\n+            (models.Model, \"models.Model\", [\"from django.db import models\"]),\n             (type(None), 'type(None)', []),\n         ]\n         for case, string, imports in special_cases:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14608", "model_patch": "--- a/django/forms/formsets.py\n+++ b/django/forms/formsets.py\n@@ -333,7 +333,7 @@\n         self._non_form_errors.\n         \"\"\"\n         self._errors = []\n-        self._non_form_errors = self.error_class()\n+        self._non_form_errors = self.error_class(error_class='nonform')\n         empty_forms_count = 0\n \n         if not self.is_bound:  # Stop further processing.\n@@ -380,7 +380,7 @@\n             # Give self.clean() a chance to do cross-form validation.\n             self.clean()\n         except ValidationError as e:\n-            self._non_form_errors = self.error_class(e.error_list)\n+            self._non_form_errors = self.error_class(e.error_list, error_class='nonform')\n \n     def clean(self):\n         \"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14631", "model_patch": "--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -166,6 +166,11 @@\n         bound_field = field.get_bound_field(self, name)\n         self._bound_fields_cache[name] = bound_field\n         return bound_field\n+\n+    def _bound_items(self):\n+        \"\"\"Yield (name, boundfield) pairs for all fields in the form.\"\"\"\n+        for name in self.fields:\n+            yield name, self[name]\n \n     @property\n     def errors(self):\n@@ -387,14 +392,15 @@\n         self._post_clean()\n \n     def _clean_fields(self):\n-        for name, field in self.fields.items():\n+        for name, bf in self._bound_items():\n+            field = bf.field\n             if field.disabled:\n-                value = self.get_initial_for_field(field, name)\n+                value = bf.initial\n             else:\n-                value = self._field_data_value(field, self.add_prefix(name))\n+                value = bf.data\n             try:\n                 if isinstance(field, FileField):\n-                    initial = self.get_initial_for_field(field, name)\n+                    initial = bf.initial\n                     value = field.clean(value, initial)\n                 else:\n                     value = field.clean(value)\n@@ -436,27 +442,7 @@\n \n     @cached_property\n     def changed_data(self):\n-        data = []\n-        for name, field in self.fields.items():\n-            data_value = self._field_data_value(field, self.add_prefix(name))\n-            if not field.show_hidden_initial:\n-                # Use the BoundField's initial as this is the value passed to\n-                # the widget.\n-                initial_value = self[name].initial\n-            else:\n-                initial_prefixed_name = self.add_initial_prefix(name)\n-                hidden_widget = field.hidden_widget()\n-                try:\n-                    initial_value = field.to_python(\n-                        self._widget_data_value(hidden_widget, initial_prefixed_name)\n-                    )\n-                except ValidationError:\n-                    # Always assume data has changed if validation fails.\n-                    data.append(name)\n-                    continue\n-            if field.has_changed(initial_value, data_value):\n-                data.append(name)\n-        return data\n+        return [name for name, bf in self._bound_items() if bf.did_change()]\n \n     @property\n     def media(self):\n\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -1,6 +1,7 @@\n import datetime\n import re\n \n+from django.core.exceptions import ValidationError\n from django.forms.utils import flatatt, pretty_name\n from django.forms.widgets import Textarea, TextInput\n from django.utils.functional import cached_property\n@@ -232,6 +233,24 @@\n     def widget_type(self):\n         return re.sub(r'widget$|input$', '', self.field.widget.__class__.__name__.lower())\n \n+    def did_change(self):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        data_value = self.data\n+        if not self.field.show_hidden_initial:\n+            # Use the BoundField's initial as this is the value passed to\n+            # the widget.\n+            initial_value = self.initial\n+        else:\n+            hidden_widget = self.field.hidden_widget()\n+            try:\n+                initial_value = self.field.to_python(\n+                    self.form._widget_data_value(hidden_widget, self.html_initial_name)\n+                )\n+            except ValidationError:\n+                # Always assume data has changed if validation fails.\n+                return True\n+        return self.field.has_changed(initial_value, data_value)\n+\n \n @html_safe\n class BoundWidget:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14672", "model_patch": "--- a/django/db/models/fields/reverse_related.py\n+++ b/django/db/models/fields/reverse_related.py\n@@ -310,7 +310,7 @@\n     def identity(self):\n         return super().identity + (\n             self.through,\n-            self.through_fields,\n+            make_hashable(self.through_fields),\n             self.db_constraint,\n         )\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14725", "model_patch": "--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -813,6 +813,9 @@\n \n     def save_new_objects(self, commit=True):\n         self.new_objects = []\n+        # If can_add is False, don't allow creation of new objects\n+        if not getattr(self, 'can_add', True):\n+            return self.new_objects\n         for form in self.extra_forms:\n             if not form.has_changed():\n                 continue\n@@ -875,7 +878,8 @@\n                          widgets=None, validate_max=False, localized_fields=None,\n                          labels=None, help_texts=None, error_messages=None,\n                          min_num=None, validate_min=False, field_classes=None,\n-                         absolute_max=None, can_delete_extra=True, renderer=None):\n+                         absolute_max=None, can_delete_extra=True, can_add=True,\n+                         renderer=None):\n     \"\"\"Return a FormSet class for the given Django model class.\"\"\"\n     meta = getattr(form, 'Meta', None)\n     if (getattr(meta, 'fields', fields) is None and\n\n--- a/django/forms/formsets.py\n+++ b/django/forms/formsets.py\n@@ -478,7 +478,7 @@\n def formset_factory(form, formset=BaseFormSet, extra=1, can_order=False,\n                     can_delete=False, max_num=None, validate_max=False,\n                     min_num=None, validate_min=False, absolute_max=None,\n-                    can_delete_extra=True, renderer=None):\n+                    can_delete_extra=True, can_add=True, renderer=None):\n     \"\"\"Return a FormSet for the given form class.\"\"\"\n     if min_num is None:\n         min_num = DEFAULT_MIN_NUM\n@@ -499,6 +499,7 @@\n         'can_order': can_order,\n         'can_delete': can_delete,\n         'can_delete_extra': can_delete_extra,\n+        'can_add': can_add,\n         'min_num': min_num,\n         'max_num': max_num,\n         'absolute_max': absolute_max,\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14752", "model_patch": "--- a/django/contrib/admin/views/autocomplete.py\n+++ b/django/contrib/admin/views/autocomplete.py\n@@ -26,11 +26,14 @@\n         context = self.get_context_data()\n         return JsonResponse({\n             'results': [\n-                {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n-                for obj in context['object_list']\n+                self.serialize_result(obj, to_field_name) for obj in context['object_list']\n             ],\n             'pagination': {'more': context['page_obj'].has_next()},\n         })\n+\n+    def serialize_result(self, obj, to_field_name):\n+        \"\"\"Convert the provided model object to a dictionary for JSON serialization.\"\"\"\n+        return {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n \n     def get_paginator(self, *args, **kwargs):\n         \"\"\"Use the ModelAdmin's paginator.\"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14765", "model_patch": "--- a/django/db/migrations/state.py\n+++ b/django/db/migrations/state.py\n@@ -91,8 +91,9 @@\n     def __init__(self, models=None, real_apps=None):\n         self.models = models or {}\n         # Apps to include from main registry, usually unmigrated ones\n-        if real_apps:\n-            self.real_apps = real_apps if isinstance(real_apps, set) else set(real_apps)\n+        if real_apps is not None:\n+            assert isinstance(real_apps, set), \"real_apps must be a set\"\n+            self.real_apps = real_apps\n         else:\n             self.real_apps = set()\n         self.is_delayed = False\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14771", "model_patch": "--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -219,7 +219,7 @@\n     import __main__\n     py_script = Path(sys.argv[0])\n \n-    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n+    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions] + ['-X%s' % (k if v is True else '%s=%s' % (k, v)) for k, v in sys._xoptions.items()]\n     # __spec__ is set when the server was started with the `-m` option,\n     # see https://docs.python.org/3/reference/import.html#main-spec\n     # __spec__ may not exist, e.g. when running in a Conda env.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14787", "model_patch": "--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -38,6 +38,9 @@\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n         bound_method = partial(method.__get__(self, type(self)))\n+        # Copy function attributes from the original method to the partial object\n+        # so that decorators using @wraps can access them without raising AttributeError\n+        update_wrapper(bound_method, method)\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14792", "model_patch": "--- a/django/utils/timezone.py\n+++ b/django/utils/timezone.py\n@@ -73,7 +73,23 @@\n \n def _get_timezone_name(timezone):\n     \"\"\"Return the name of ``timezone``.\"\"\"\n-    return str(timezone)\n+    timezone_name = str(timezone)\n+    \n+    # Handle Etc/GMT timezone names by converting to simple offset format\n+    # Etc/GMT-10 means +10 hours from UTC (POSIX convention is counterintuitive)\n+    if timezone_name.startswith('Etc/GMT'):\n+        if timezone_name == 'Etc/GMT':\n+            return '+0'\n+        elif 'Etc/GMT-' in timezone_name:\n+            # Etc/GMT-10 -> +10 (invert the sign)\n+            offset = timezone_name.split('Etc/GMT-')[1]\n+            return '+' + offset\n+        elif 'Etc/GMT+' in timezone_name:\n+            # Etc/GMT+5 -> -5 (invert the sign)\n+            offset = timezone_name.split('Etc/GMT+')[1]\n+            return '-' + offset\n+    \n+    return timezone_name\n \n # Timezone selection functions.\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14855", "model_patch": "--- a/django/contrib/admin/helpers.py\n+++ b/django/contrib/admin/helpers.py\n@@ -209,7 +209,7 @@\n             remote_field.model._meta.model_name,\n         )\n         try:\n-            url = reverse(url_name, args=[quote(remote_obj.pk)])\n+            url = reverse(url_name, args=[quote(remote_obj.pk)], current_app=self.model_admin.admin_site.name)\n             return format_html('<a href=\"{}\">{}</a>', url, remote_obj)\n         except NoReverseMatch:\n             return str(remote_obj)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14915", "model_patch": "--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1171,6 +1171,9 @@\n             other = other.value\n         return self.value == other\n \n+    def __hash__(self):\n+        return hash(self.value)\n+\n \n class ModelChoiceIterator:\n     def __init__(self, field):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-14999", "model_patch": "--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -320,6 +320,11 @@\n         new_model = to_state.apps.get_model(app_label, self.new_name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n             old_model = from_state.apps.get_model(app_label, self.old_name)\n+            # If both models have custom db_table values, this should be a no-op\n+            old_db_table_is_custom = 'db_table' in old_model._meta.original_attrs\n+            new_db_table_is_custom = 'db_table' in new_model._meta.original_attrs\n+            if old_db_table_is_custom and new_db_table_is_custom:\n+                return\n             # Move the main table\n             schema_editor.alter_db_table(\n                 new_model,\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15022", "model_patch": "--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1031,6 +1031,7 @@\n         if search_fields and search_term:\n             orm_lookups = [construct_search(str(search_field))\n                            for search_field in search_fields]\n+            all_queries = []\n             for bit in smart_split(search_term):\n                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                     bit = unescape_string_literal(bit)\n@@ -1038,7 +1039,9 @@\n                     *((orm_lookup, bit) for orm_lookup in orm_lookups),\n                     _connector=models.Q.OR,\n                 )\n-                queryset = queryset.filter(or_queries)\n+                all_queries.append(or_queries)\n+            if all_queries:\n+                queryset = queryset.filter(models.Q(*all_queries, _connector=models.Q.AND))\n             may_have_duplicates |= any(\n                 lookup_spawns_duplicates(self.opts, search_spec)\n                 for search_spec in orm_lookups\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15037", "model_patch": "--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -124,6 +124,19 @@\n                             \"self\" if relations[column_name][1] == table_name\n                             else table2model(relations[column_name][1])\n                         )\n+                        \n+                        # Check if the foreign key references a non-primary key field\n+                        referenced_field = relations[column_name][0]\n+                        referenced_table = relations[column_name][1]\n+                        if referenced_table != table_name:  # Don't check primary key for self-references\n+                            try:\n+                                referenced_pk = connection.introspection.get_primary_key_column(cursor, referenced_table)\n+                                if referenced_pk and referenced_field != referenced_pk:\n+                                    extra_params['to_field'] = referenced_field\n+                            except Exception:\n+                                # If we can't determine the primary key, skip adding to_field\n+                                pass\n+                        \n                         if rel_to in known_models:\n                             field_type = '%s(%s' % (rel_type, rel_to)\n                         else:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15098", "model_patch": "--- a/django/utils/translation/trans_real.py\n+++ b/django/utils/translation/trans_real.py\n@@ -43,7 +43,7 @@\n     re.IGNORECASE\n )\n \n-language_code_prefix_re = _lazy_re_compile(r'^/(\\w+([@-]\\w+)?)(/|$)')\n+language_code_prefix_re = _lazy_re_compile(r'^/([a-z]{1,8}(?:[-@][a-z0-9]{1,8})*)(/|$)', re.IGNORECASE)\n \n \n @receiver(setting_changed)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15103", "model_patch": "--- a/django/template/defaultfilters.py\n+++ b/django/template/defaultfilters.py\n@@ -83,7 +83,7 @@\n \n \n @register.filter(is_safe=True)\n-def json_script(value, element_id):\n+def json_script(value, element_id=None):\n     \"\"\"\n     Output value JSON-encoded, wrapped in a <script type=\"application/json\">\n     tag.\n\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -61,7 +61,7 @@\n }\n \n \n-def json_script(value, element_id):\n+def json_script(value, element_id=None):\n     \"\"\"\n     Escape all the HTML/XML special characters with their unicode escapes, so\n     value is safe to be output anywhere except for inside a tag attribute. Wrap\n@@ -69,10 +69,16 @@\n     \"\"\"\n     from django.core.serializers.json import DjangoJSONEncoder\n     json_str = json.dumps(value, cls=DjangoJSONEncoder).translate(_json_script_escapes)\n-    return format_html(\n-        '<script id=\"{}\" type=\"application/json\">{}</script>',\n-        element_id, mark_safe(json_str)\n-    )\n+    if element_id is None:\n+        return format_html(\n+            '<script type=\"application/json\">{}</script>',\n+            mark_safe(json_str)\n+        )\n+    else:\n+        return format_html(\n+            '<script id=\"{}\" type=\"application/json\">{}</script>',\n+            element_id, mark_safe(json_str)\n+        )\n \n \n def conditional_escape(text):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15104", "model_patch": "--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -96,7 +96,7 @@\n         for name, field in sorted(fields.items()):\n             deconstruction = self.deep_deconstruct(field)\n             if field.remote_field and field.remote_field.model:\n-                del deconstruction[2]['to']\n+                deconstruction[2].pop('to', None)\n             fields_def.append(deconstruction)\n         return fields_def\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15127", "model_patch": "--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -38,7 +38,7 @@\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15128", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -761,7 +761,13 @@\n \n         # Create a new alias for this table.\n         if alias_list:\n-            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n+            # Find the next available alias number that doesn't conflict with existing aliases\n+            counter = len(self.alias_map) + 1\n+            while True:\n+                alias = '%s%d' % (self.alias_prefix, counter)\n+                if alias not in self.alias_map:\n+                    break\n+                counter += 1\n             alias_list.append(alias)\n         else:\n             # The first occurrence of a table uses the table name directly.\n@@ -846,6 +852,10 @@\n         relabelling any references to them in select columns and the where\n         clause.\n         \"\"\"\n+        # Ensure that no alias is changed twice by checking that the set of keys\n+        # and the set of values in change_map don't intersect. This prevents\n+        # scenarios where an alias might be changed from T4 -> T5 and then\n+        # T5 -> T6 in the same operation, which would cause incorrect relabeling.\n         assert set(change_map).isdisjoint(change_map.values())\n \n         # 1. Update references in \"select\" (normal columns plus aliases),\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15252", "model_patch": "--- a/django/db/migrations/recorder.py\n+++ b/django/db/migrations/recorder.py\n@@ -1,5 +1,5 @@\n from django.apps.registry import Apps\n-from django.db import DatabaseError, models\n+from django.db import DatabaseError, models, router\n from django.utils.functional import classproperty\n from django.utils.timezone import now\n \n@@ -62,6 +62,9 @@\n         # in the codebase.\n         if self.has_table():\n             return\n+        # Check if migrations are allowed on this database\n+        if not router.allow_migrate(self.connection.alias, 'migrations'):\n+            return\n         # Make the table\n         try:\n             with self.connection.schema_editor() as editor:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15268", "model_patch": "--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -476,6 +476,16 @@\n         setattr(self, self.option_name, option_value)\n         super().__init__(name)\n \n+    def reduce(self, operation, app_label):\n+        if (isinstance(operation, self.__class__) and\n+                self.name_lower == operation.name_lower and\n+                not self.option_value and\n+                operation.option_value):\n+            # Optimize case where current operation sets constraint to empty\n+            # and next operation sets it to non-empty - just use the second operation\n+            return [operation]\n+        return super().reduce(operation, app_label)\n+\n     @cached_property\n     def option_value(self):\n         return getattr(self, self.option_name)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15277", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1010,7 +1010,8 @@\n     def __init__(self, *args, db_collation=None, **kwargs):\n         super().__init__(*args, **kwargs)\n         self.db_collation = db_collation\n-        self.validators.append(validators.MaxLengthValidator(self.max_length))\n+        if self.max_length is not None:\n+            self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n     def check(self, **kwargs):\n         databases = kwargs.get('databases') or []\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15278", "model_patch": "--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -327,7 +327,9 @@\n         # Fields with default values cannot by handled by ALTER TABLE ADD\n         # COLUMN statement because DROP DEFAULT is not supported in\n         # ALTER TABLE.\n-        if not field.null or self.effective_default(field) is not None:\n+        # Fields with unique constraints cannot be handled by ALTER TABLE ADD\n+        # COLUMN statement because SQLite doesn't support adding UNIQUE columns.\n+        if not field.null or self.effective_default(field) is not None or field.unique:\n             self._remake_table(model, create_field=field)\n         else:\n             super().add_field(model, field)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15315", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -542,11 +542,7 @@\n         return NotImplemented\n \n     def __hash__(self):\n-        return hash((\n-            self.creation_counter,\n-            self.model._meta.app_label if hasattr(self, 'model') else None,\n-            self.model._meta.model_name if hasattr(self, 'model') else None,\n-        ))\n+        return hash(self.creation_counter)\n \n     def __deepcopy__(self, memodict):\n         # We don't have to deepcopy very much here, since most things are not\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15368", "model_patch": "--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -670,7 +670,7 @@\n                 when_statements = []\n                 for obj in batch_objs:\n                     attr = getattr(obj, field.attname)\n-                    if not isinstance(attr, Expression):\n+                    if not hasattr(attr, 'resolve_expression'):\n                         attr = Value(attr, output_field=field)\n                     when_statements.append(When(pk=obj.pk, then=attr))\n                 case_statement = Case(*when_statements, output_field=field)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15375", "model_patch": "--- a/django/db/models/functions/comparison.py\n+++ b/django/db/models/functions/comparison.py\n@@ -72,6 +72,10 @@\n             if result is NotImplemented or result is not None:\n                 return result\n         return None\n+\n+    @property\n+    def is_summary(self):\n+        return any(getattr(expr, 'is_summary', False) for expr in self.get_source_expressions())\n \n     def as_oracle(self, compiler, connection, **extra_context):\n         # Oracle prohibits mixing TextField (NCLOB) and CharField (NVARCHAR2),\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15380", "model_patch": "--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -824,7 +824,7 @@\n         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n             old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, old_model_name]\n+            new_model_state = self.to_state.models[app_label, model_name]\n             field = new_model_state.get_field(field_name)\n             # Scan to see if this is actually a rename!\n             field_dec = self.deep_deconstruct(field)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15382", "model_patch": "--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1211,15 +1211,26 @@\n \n     def as_sql(self, compiler, connection, template=None, **extra_context):\n         query = self.query.exists(using=connection.alias)\n-        sql, params = super().as_sql(\n-            compiler,\n-            connection,\n-            template=template,\n-            query=query,\n-            **extra_context,\n-        )\n-        if self.negated:\n-            sql = 'NOT {}'.format(sql)\n+        try:\n+            sql, params = super().as_sql(\n+                compiler,\n+                connection,\n+                template=template,\n+                query=query,\n+                **extra_context,\n+            )\n+        except EmptyResultSet:\n+            # Handle empty subquery case\n+            if self.negated:\n+                # ~Exists with empty subquery should be TRUE\n+                sql = 'SELECT 1 WHERE TRUE'\n+            else:\n+                # Exists with empty subquery should be FALSE\n+                sql = 'SELECT 1 WHERE FALSE'\n+            params = []\n+        else:\n+            if self.negated:\n+                sql = 'NOT {}'.format(sql)\n         return sql, params\n \n     def select_format(self, compiler, sql, params):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15467", "model_patch": "--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -269,7 +269,7 @@\n                         \"class\": get_ul_class(self.radio_fields[db_field.name]),\n                     }\n                 )\n-                kwargs[\"empty_label\"] = _(\"None\") if db_field.blank else None\n+                kwargs[\"empty_label\"] = (kwargs.get(\"empty_label\") or _(\"None\")) if db_field.blank else None\n \n         if \"queryset\" not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15499", "model_patch": "--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -168,6 +168,19 @@\n                     options=options,\n                     bases=self.bases,\n                     managers=self.managers,\n+                ),\n+            ]\n+        elif (\n+            isinstance(operation, AlterModelManagers)\n+            and self.name_lower == operation.name_lower\n+        ):\n+            return [\n+                CreateModel(\n+                    self.name,\n+                    fields=self.fields,\n+                    options=self.options,\n+                    bases=self.bases,\n+                    managers=operation.managers,\n                 ),\n             ]\n         elif (\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15503", "model_patch": "--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -193,11 +193,17 @@\n                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n             else:\n                 rhs_key_transforms = [key]\n+            # For has_key operations, always treat keys as object properties\n+            # rather than potentially treating numeric strings as array indices\n+            key_path_parts = []\n+            for key_transform in rhs_key_transforms:\n+                key_path_parts.append(\".\")\n+                key_path_parts.append(json.dumps(key_transform))\n             rhs_params.append(\n                 \"%s%s\"\n                 % (\n                     lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n+                    \"\".join(key_path_parts),\n                 )\n             )\n         # Add condition for each key.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15525", "model_patch": "--- a/django/core/serializers/base.py\n+++ b/django/core/serializers/base.py\n@@ -336,7 +336,9 @@\n         and hasattr(default_manager, \"get_by_natural_key\")\n         and hasattr(Model, \"natural_key\")\n     ):\n-        natural_key = Model(**data).natural_key()\n+        temp_instance = Model(**data)\n+        temp_instance._state.db = db\n+        natural_key = temp_instance.natural_key()\n         try:\n             data[Model._meta.pk.attname] = Model._meta.pk.to_python(\n                 default_manager.db_manager(db).get_by_natural_key(*natural_key).pk\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15554", "model_patch": "--- a/django/db/models/sql/datastructures.py\n+++ b/django/db/models/sql/datastructures.py\n@@ -162,8 +162,8 @@\n         return hash(self.identity)\n \n     def equals(self, other):\n-        # Ignore filtered_relation in equality check.\n-        return self.identity[:-1] == other.identity[:-1]\n+        # Include filtered_relation in equality check.\n+        return self.identity == other.identity\n \n     def demote(self):\n         new = self.relabeled_clone({})\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15561", "model_patch": "--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -524,6 +524,35 @@\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def _field_should_be_altered(self, old_field, new_field):\n+        _, old_path, old_args, old_kwargs = old_field.deconstruct()\n+        _, new_path, new_args, new_kwargs = new_field.deconstruct()\n+        # Don't alter when:\n+        # - changing only a field name\n+        # - changing an attribute that doesn't affect the schema\n+        # - adding only a db_column and the column name is not changed\n+        non_database_attrs = [\n+            \"blank\",\n+            \"choices\",\n+            \"db_column\",\n+            \"editable\",\n+            \"error_messages\",\n+            \"help_text\",\n+            \"limit_choices_to\",\n+            # Database-level options are not supported, see #21961.\n+            \"on_delete\",\n+            \"related_name\",\n+            \"related_query_name\",\n+            \"validators\",\n+            \"verbose_name\",\n+        ]\n+        for attr in non_database_attrs:\n+            old_kwargs.pop(attr, None)\n+            new_kwargs.pop(attr, None)\n+        return self.quote_name(old_field.column) != self.quote_name(\n+            new_field.column\n+        ) or (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15569", "model_patch": "--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -217,6 +217,7 @@\n         if lookup_name is None:\n             lookup_name = lookup.lookup_name\n         del cls.class_lookups[lookup_name]\n+        cls._clear_cached_lookups()\n \n \n def select_related_descend(field, restricted, requested, load_fields, reverse=False):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15572", "model_patch": "--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -17,7 +17,7 @@\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        items.update(cwd / to_path(dir) for dir in backend.engine.dirs if dir)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, \"get_dirs\"):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15629", "model_patch": "--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1038,9 +1038,19 @@\n         for old_rel, new_rel in rels_to_update:\n             rel_db_params = new_rel.field.db_parameters(connection=self.connection)\n             rel_type = rel_db_params[\"type\"]\n-            fragment, other_actions = self._alter_column_type_sql(\n-                new_rel.related_model, old_rel.field, new_rel.field, rel_type\n-            )\n+            # Check if the referenced field has a collation change\n+            rel_old_collation = old_db_params.get(\"collation\")\n+            rel_new_collation = new_db_params.get(\"collation\")\n+            if rel_old_collation != rel_new_collation:\n+                # Use collation-aware SQL for foreign key field update\n+                fragment = self._alter_column_collation_sql(\n+                    new_rel.related_model, new_rel.field, rel_type, rel_new_collation\n+                )\n+                other_actions = []\n+            else:\n+                fragment, other_actions = self._alter_column_type_sql(\n+                    new_rel.related_model, old_rel.field, new_rel.field, rel_type\n+                )\n             self.execute(\n                 self.sql_alter_column\n                 % {\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15695", "model_patch": "--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -936,6 +936,13 @@\n         if not self.allow_migrate_model(schema_editor.connection.alias, model):\n             return\n \n+        # Check if target index already exists to make operation idempotent\n+        existing_index_names = schema_editor._constraint_names(\n+            model, index=True\n+        )\n+        if self.new_name in existing_index_names:\n+            return\n+\n         if self.old_fields:\n             from_model = from_state.apps.get_model(app_label, self.model_name)\n             columns = [\n@@ -966,8 +973,38 @@\n         schema_editor.rename_index(model, old_index, new_index)\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        model = from_state.apps.get_model(app_label, self.model_name)\n+        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n+            return\n+\n         if self.old_fields:\n-            # Backward operation with unnamed index is a no-op.\n+            # For unnamed indexes, we need to rename back to the auto-generated name\n+            # First, check if the new_name index exists\n+            existing_index_names = schema_editor._constraint_names(\n+                model, index=True\n+            )\n+            if self.new_name not in existing_index_names:\n+                return\n+\n+            # Generate the original auto-generated name\n+            to_model = to_state.apps.get_model(app_label, self.model_name)\n+            columns = [\n+                to_model._meta.get_field(field).column for field in self.old_fields\n+            ]\n+            original_auto_name = schema_editor._create_index_name(\n+                to_model._meta.db_table, columns, suffix=\"idx\"\n+            )\n+\n+            # Create index objects for the rename operation\n+            current_index = models.Index(\n+                fields=self.old_fields,\n+                name=self.new_name,\n+            )\n+            target_index = models.Index(\n+                fields=self.old_fields,\n+                name=original_auto_name,\n+            )\n+            schema_editor.rename_index(model, current_index, target_index)\n             return\n \n         self.new_name_lower, self.old_name_lower = (\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15731", "model_patch": "--- a/django/db/models/manager.py\n+++ b/django/db/models/manager.py\n@@ -1,4 +1,5 @@\n import copy\n+import functools\n import inspect\n from importlib import import_module\n \n@@ -81,11 +82,10 @@\n     @classmethod\n     def _get_queryset_methods(cls, queryset_class):\n         def create_method(name, method):\n+            @functools.wraps(method)\n             def manager_method(self, *args, **kwargs):\n                 return getattr(self.get_queryset(), name)(*args, **kwargs)\n \n-            manager_method.__name__ = method.__name__\n-            manager_method.__doc__ = method.__doc__\n             return manager_method\n \n         new_methods = {}\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15732", "model_patch": "--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -562,6 +562,12 @@\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        # When looking for unique constraints to drop, exclude primary key constraints\n+        # to avoid conflicts when both a primary key and unique_together constraint\n+        # exist on the same column(s)\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_kwargs = constraint_kwargs.copy()\n+            constraint_kwargs[\"primary_key\"] = False\n         constraint_names = self._constraint_names(\n             model,\n             columns,\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15741", "model_patch": "--- a/django/utils/formats.py\n+++ b/django/utils/formats.py\n@@ -7,6 +7,7 @@\n \n from django.conf import settings\n from django.utils import dateformat, numberformat\n+from django.utils.encoding import force_str\n from django.utils.functional import lazy\n from django.utils.translation import check_for_language, get_language, to_locale\n \n@@ -106,6 +107,7 @@\n     If use_l10n is provided and is not None, it forces the value to\n     be localized (or not), overriding the value of settings.USE_L10N.\n     \"\"\"\n+    format_type = force_str(format_type)\n     if use_l10n is None:\n         try:\n             use_l10n = settings._USE_L10N_INTERNAL\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15814", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,7 +748,7 @@\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+                opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15851", "model_patch": "--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -32,9 +32,9 @@\n             args += [\"-h\", host]\n         if port:\n             args += [\"-p\", str(port)]\n+        args.extend(parameters)\n         if dbname:\n             args += [dbname]\n-        args.extend(parameters)\n \n         env = {}\n         if passwd:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15863", "model_patch": "--- a/django/template/defaultfilters.py\n+++ b/django/template/defaultfilters.py\n@@ -151,8 +151,12 @@\n             use_l10n = False\n             arg = arg[:-1] or -1\n     try:\n-        input_val = repr(text)\n-        d = Decimal(input_val)\n+        if isinstance(text, Decimal):\n+            input_val = str(text)\n+            d = text\n+        else:\n+            input_val = repr(text)\n+            d = Decimal(input_val)\n     except InvalidOperation:\n         try:\n             d = Decimal(str(float(text)))\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15916", "model_patch": "--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -630,6 +630,10 @@\n     # creating needs to inherit from the parent's inner meta.\n     bases = (form.Meta,) if hasattr(form, \"Meta\") else ()\n     Meta = type(\"Meta\", bases, attrs)\n+    # If no explicit formfield_callback is provided, check if the base form has one\n+    if formfield_callback is None and hasattr(form, 'Meta') and hasattr(form.Meta, 'formfield_callback'):\n+        formfield_callback = form.Meta.formfield_callback\n+    \n     if formfield_callback:\n         Meta.formfield_callback = staticmethod(formfield_callback)\n     # Give this new form class a reasonable name.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15930", "model_patch": "--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,7 +1298,16 @@\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n-        condition_sql, condition_params = compiler.compile(self.condition)\n+        try:\n+            condition_sql, condition_params = compiler.compile(self.condition)\n+        except EmptyResultSet:\n+            # Handle EmptyResultSet for negated conditions like ~Q(pk__in=[])\n+            # A negated empty condition should match everything (1=1)\n+            if getattr(self.condition, 'negated', False):\n+                condition_sql, condition_params = \"1=1\", []\n+            else:\n+                # Non-negated empty condition should match nothing (1=0)\n+                condition_sql, condition_params = \"1=0\", []\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15957", "model_patch": "--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -659,6 +659,10 @@\n             empty_strings_as_null = connections[\n                 db\n             ].features.interprets_empty_strings_as_nulls\n+            # Clone the queryset if it's sliced to remove slice information\n+            # This allows filtering to proceed normally\n+            if queryset.query.is_sliced:\n+                queryset = queryset._chain()\n             queryset._add_hints(instance=self.instance)\n             if self._db:\n                 queryset = queryset.using(self._db)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15973", "model_patch": "--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -450,8 +450,14 @@\n \n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through = field.remote_field.through\n+            # Handle case where through is still a string reference\n+            if isinstance(through, str):\n+                # Skip creating tables for string references during migrations\n+                # as they will be handled when the actual through model is processed\n+                continue\n+            if through._meta.auto_created:\n+                self.create_model(through)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15987", "model_patch": "--- a/django/core/management/commands/loaddata.py\n+++ b/django/core/management/commands/loaddata.py\n@@ -362,7 +362,9 @@\n         \"\"\"\n         dirs = []\n         fixture_dirs = settings.FIXTURE_DIRS\n-        if len(fixture_dirs) != len(set(fixture_dirs)):\n+        # Convert Path instances to strings and normalize paths before duplicate check\n+        normalized_fixture_dirs = [os.path.realpath(str(d)) for d in fixture_dirs]\n+        if len(normalized_fixture_dirs) != len(set(normalized_fixture_dirs)):\n             raise ImproperlyConfigured(\"settings.FIXTURE_DIRS contains duplicates.\")\n         for app_config in apps.get_app_configs():\n             app_label = app_config.label\n@@ -380,7 +382,7 @@\n                 dirs.append(app_dir)\n         dirs.extend(fixture_dirs)\n         dirs.append(\"\")\n-        return [os.path.realpath(d) for d in dirs]\n+        return [os.path.realpath(str(d)) for d in dirs]\n \n     def parse_name(self, fixture_name):\n         \"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-16032", "model_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1115,7 +1115,10 @@\n         if select:\n             self.append_annotation_mask([alias])\n         else:\n-            self.set_annotation_mask(set(self.annotation_select).difference({alias}))\n+            # For alias operations, ensure the alias is not in the selection mask\n+            # but don't automatically include all existing annotations\n+            if self.annotation_select_mask is not None:\n+                self.annotation_select_mask.discard(alias)\n         self.annotations[alias] = annotation\n \n     def resolve_expression(self, query, *args, **kwargs):\n\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -1180,6 +1180,30 @@\n             friday_night_closing=datetime.time(23, 59, 59),\n         )\n \n+    def test_annotation_and_alias_filter_in_subquery(self):\n+        long_books_qs = (\n+            Book.objects.filter(\n+                pages__gt=400,\n+            )\n+            .annotate(book_annotate=Value(1))\n+            .alias(book_alias=Value(1))\n+        )\n+        publisher_books_qs = (\n+            Publisher.objects.filter(\n+                book__in=long_books_qs\n+            )\n+            .values(\"name\")\n+        )\n+        self.assertCountEqual(\n+            publisher_books_qs,\n+            [\n+                {'name': 'Apress'},\n+                {'name': 'Sams'},\n+                {'name': 'Prentice Hall'},\n+                {'name': 'Morgan Kaufmann'}\n+            ]\n+        )\n+\n     def test_basic_alias(self):\n         qs = Book.objects.alias(is_book=Value(1))\n         self.assertIs(hasattr(qs.first(), \"is_book\"), False)\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-16082", "model_patch": "--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -533,6 +533,7 @@\n             Combinable.SUB,\n             Combinable.MUL,\n             Combinable.DIV,\n+            Combinable.MOD,\n         )\n     },\n     # Bitwise operators.\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-16100", "model_patch": "--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -2010,26 +2010,27 @@\n                 request.POST, request.FILES, queryset=modified_objects\n             )\n             if formset.is_valid():\n-                changecount = 0\n-                for form in formset.forms:\n-                    if form.has_changed():\n-                        obj = self.save_form(request, form, change=True)\n-                        self.save_model(request, obj, form, change=True)\n-                        self.save_related(request, form, formsets=[], change=True)\n-                        change_msg = self.construct_change_message(request, form, None)\n-                        self.log_change(request, obj, change_msg)\n-                        changecount += 1\n-\n-                if changecount:\n-                    msg = ngettext(\n-                        \"%(count)s %(name)s was changed successfully.\",\n-                        \"%(count)s %(name)s were changed successfully.\",\n-                        changecount,\n-                    ) % {\n-                        \"count\": changecount,\n-                        \"name\": model_ngettext(self.opts, changecount),\n-                    }\n-                    self.message_user(request, msg, messages.SUCCESS)\n+                with transaction.atomic():\n+                    changecount = 0\n+                    for form in formset.forms:\n+                        if form.has_changed():\n+                            obj = self.save_form(request, form, change=True)\n+                            self.save_model(request, obj, form, change=True)\n+                            self.save_related(request, form, formsets=[], change=True)\n+                            change_msg = self.construct_change_message(request, form, None)\n+                            self.log_change(request, obj, change_msg)\n+                            changecount += 1\n+\n+                    if changecount:\n+                        msg = ngettext(\n+                            \"%(count)s %(name)s was changed successfully.\",\n+                            \"%(count)s %(name)s were changed successfully.\",\n+                            changecount,\n+                        ) % {\n+                            \"count\": changecount,\n+                            \"name\": model_ngettext(self.opts, changecount),\n+                        }\n+                        self.message_user(request, msg, messages.SUCCESS)\n \n                 return HttpResponseRedirect(request.get_full_path())\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-16116", "model_patch": "--- a/django/core/management/commands/makemigrations.py\n+++ b/django/core/management/commands/makemigrations.py\n@@ -248,12 +248,12 @@\n                 else:\n                     self.log(\"No changes detected\")\n         else:\n+            if check_changes:\n+                sys.exit(1)\n             if self.update:\n                 self.write_to_last_migration_files(changes)\n             else:\n                 self.write_migration_files(changes)\n-            if check_changes:\n-                sys.exit(1)\n \n     def write_to_last_migration_files(self, changes):\n         loader = MigrationLoader(connections[DEFAULT_DB_ALIAS])\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-16136", "model_patch": "--- a/django/views/generic/base.py\n+++ b/django/views/generic/base.py\n@@ -148,7 +148,16 @@\n             request.path,\n             extra={\"status_code\": 405, \"request\": request},\n         )\n-        return HttpResponseNotAllowed(self._allowed_methods())\n+        response = HttpResponseNotAllowed(self._allowed_methods())\n+        \n+        if self.view_is_async:\n+\n+            async def func():\n+                return response\n+\n+            return func()\n+        else:\n+            return response\n \n     def options(self, request, *args, **kwargs):\n         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-16139", "model_patch": "--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -163,7 +163,7 @@\n         super().__init__(*args, **kwargs)\n         password = self.fields.get(\"password\")\n         if password:\n-            password.help_text = password.help_text.format(\"../password/\")\n+            password.help_text = password.help_text.format(f\"../../{self.instance.pk}/password/\")\n         user_permissions = self.fields.get(\"user_permissions\")\n         if user_permissions:\n             user_permissions.queryset = user_permissions.queryset.select_related(\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-16145", "model_patch": "--- a/django/core/management/commands/runserver.py\n+++ b/django/core/management/commands/runserver.py\n@@ -147,7 +147,7 @@\n                 \"version\": self.get_version(),\n                 \"settings\": settings.SETTINGS_MODULE,\n                 \"protocol\": self.protocol,\n-                \"addr\": \"[%s]\" % self.addr if self._raw_ipv6 else self.addr,\n+                \"addr\": \"[%s]\" % self.addr if self._raw_ipv6 else (\"0.0.0.0\" if self.addr == \"0\" else self.addr),\n                 \"port\": self.port,\n                 \"quit_command\": quit_command,\n             }\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-7530", "model_patch": "--- a/django/core/management/commands/makemigrations.py\n+++ b/django/core/management/commands/makemigrations.py\n@@ -105,7 +105,7 @@\n                     # At least one model must be migrated to the database.\n                     router.allow_migrate(connection.alias, app_label, model_name=model._meta.object_name)\n                     for app_label in consistency_check_labels\n-                    for model in apps.get_models(app_label)\n+                    for model in apps.get_app_config(app_label).get_models()\n             )):\n                 loader.check_consistent_history(connection)\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-9296", "model_patch": "--- a/django/core/paginator.py\n+++ b/django/core/paginator.py\n@@ -106,6 +106,10 @@\n         \"\"\"\n         return range(1, self.num_pages + 1)\n \n+    def __iter__(self):\n+        for page_num in self.page_range:\n+            yield self.page(page_num)\n+\n     def _check_object_list_is_ordered(self):\n         \"\"\"\n         Warn if self.object_list is unordered (typically a QuerySet).\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15161", "model_patch": "--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -390,7 +390,7 @@\n         return sql, params\n \n \n-@deconstructible\n+@deconstructible(path='django.db.models.Expression')\n class Expression(BaseExpression, Combinable):\n     \"\"\"An expression that can be combined with other expressions.\"\"\"\n \n@@ -731,6 +731,7 @@\n         return copy\n \n \n+@deconstructible(path='django.db.models.Value')\n class Value(SQLiteNumericMixin, Expression):\n     \"\"\"Represent a wrapped value as a node within an expression.\"\"\"\n     # Provide a default value for `for_save` in order to allow unresolved\n@@ -953,6 +954,7 @@\n         return super().as_sql(*args, **kwargs)\n \n \n+@deconstructible(path='django.db.models.ExpressionWrapper')\n class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     \"\"\"\n     An expression that can wrap another expression so that it can provide\n@@ -985,6 +987,7 @@\n         return \"{}({})\".format(self.__class__.__name__, self.expression)\n \n \n+@deconstructible(path='django.db.models.When')\n class When(Expression):\n     template = 'WHEN %(condition)s THEN %(result)s'\n     # This isn't a complete conditional expression, must be used in Case().\n@@ -1052,6 +1055,7 @@\n         return cols\n \n \n+@deconstructible(path='django.db.models.Case')\n class Case(SQLiteNumericMixin, Expression):\n     \"\"\"\n     An SQL searched CASE expression:\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15563", "model_patch": "--- a/django/db/models/sql/subqueries.py\n+++ b/django/db/models/sql/subqueries.py\n@@ -134,7 +134,10 @@\n             query = UpdateQuery(model)\n             query.values = values\n             if self.related_ids is not None:\n-                query.add_filter(\"pk__in\", self.related_ids)\n+                # For multiple inheritance, use the correct primary key field\n+                # for each parent model instead of generic 'pk'\n+                pk_field_name = model._meta.pk.name\n+                query.add_filter(f\"{pk_field_name}__in\", self.related_ids)\n             result.append(query)\n         return result\n \n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-15280", "model_patch": "--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -539,6 +539,27 @@\n         new = cls(*values)\n         new._state.adding = False\n         new._state.db = db\n+        \n+        # Ensure that only fields not in field_names are treated as deferred\n+        # by clearing any field values that shouldn't be in the instance's __dict__\n+        # This prevents incorrect inheritance of deferred field state from previous contexts\n+        loaded_field_names = set(field_names)\n+        for field in cls._meta.concrete_fields:\n+            if field.attname not in loaded_field_names:\n+                # Field was not loaded, ensure it's not in __dict__ so it's properly deferred\n+                if field.attname in new.__dict__:\n+                    delattr(new, field.attname)\n+            else:\n+                # Field was explicitly loaded, ensure it's not treated as deferred\n+                # even if a previous instance had it deferred. This prevents incorrect\n+                # inheritance of deferred field state.\n+                if field.attname not in new.__dict__ and hasattr(new, field.attname):\n+                    # If the field has a value but it's not in __dict__ (e.g., due to\n+                    # deferred attribute descriptors), we need to ensure the actual\n+                    # loaded value is properly set in __dict__\n+                    field_value = getattr(new, field.attname)\n+                    setattr(new, field.attname, field_value)\n+        \n         return new\n \n     def __repr__(self):\n", "model_name_or_path": "DeepSeek_IA"}
{"instance_id": "django__django-12273", "model_patch": "--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -501,6 +501,16 @@\n                 raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\n         super().__init__()\n         post_init.send(sender=cls, instance=self)\n+\n+    def __setattr__(self, name, value):\n+        # Check if we're setting the primary key to None\n+        if (hasattr(self, '_meta') and \n+            hasattr(self, '_state') and \n+            name == self._meta.pk.attname and \n+            value is None):\n+            # Reset the adding flag to True so the next save() will INSERT\n+            self._state.adding = True\n+        super().__setattr__(name, value)\n \n     @classmethod\n     def from_db(cls, db, field_names, values):\n", "model_name_or_path": "DeepSeek_IA"}
